[{"title":"Flutter学习","date":"2019-03-08T10:05:23.000Z","path":"2019/03/08/flutter/flutter-res/","text":"Flutter学习资源官方网站：https://flutter.dev/ 中文网站：https://flutterchina.club/ 电子书：https://book.flutterchina.club/ 开源库地址：https://pub.dartlang.org/ Flutter掘金社区：https://juejin.im/tag/Flutter 闲鱼社区：https://juejin.im/user/5ac2db47f265da2393774122 Dart学习网站：https://www.dartlang.org/ DartPad(在线编写Dart代码)：https://dartpad.dartlang.org/ 开源项目超完整的Flutter项目，功能丰富，适合学习和日常使用： https://github.com/CarGuo/GSYGithubAppFlutter 阿里开源的Flutter项目，flutter 开发者帮助 APP，包含 flutter 常用 140+ 组件的demo 演示与中文文档 https://github.com/alibaba/flutter-go Flutter交流群QQ：399314271、771482762","tags":[{"name":"flutter","slug":"flutter","permalink":"yzbzz.github.io/tags/flutter/"}]},{"title":"flutter_basic","date":"2019-02-20T08:18:53.000Z","path":"2019/02/20/flutter/flutter-basic/","text":"简介StatelessWidget","tags":[{"name":"flutter","slug":"flutter","permalink":"yzbzz.github.io/tags/flutter/"}]},{"title":"git-error","date":"2019-01-07T03:34:06.000Z","path":"2019/01/07/hole/git-error/","text":"SSH: connect to host xxx prot 22: connection refused 12git remote rm origingit remote add origin http://xxx","tags":[{"name":"hole","slug":"hole","permalink":"yzbzz.github.io/tags/hole/"}]},{"title":"","date":"2018-11-13T03:42:03.643Z","path":"2018/11/13/android/Untitled/","text":"","tags":[]},{"title":"Webpack安装vue","date":"2018-09-21T10:12:07.000Z","path":"2018/09/21/fe/webpack-vue/","text":"入门 Webpack，看这篇就够了 安装Vue安装vue 1npm install --save vue 安装vue-loader，vue-template-compiler是vue-loader必须的依赖 1npm install --save-dev vue-loader vue-template-compiler BabelBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的： 让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持； 让你能使用基于JavaScript进行了拓展的语言，比如React的JSX； Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。 我们先来一次性安装这些依赖包 1npm install --save-dev babel-core babel-loader babel-preset-env CSSwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 1npm install --save-dev style-loader css-loader","tags":[{"name":"fe","slug":"fe","permalink":"yzbzz.github.io/tags/fe/"}]},{"title":"study-gitlab","date":"2018-09-11T03:28:43.000Z","path":"2018/09/11/study/study-gitlab/","text":"备份与还原1gitlab-rake gitlab:backup:create 发果出现下面的提示 1Errno::EACCES: Permission denied @ dir_s_mkdir - /var/opt/gitlab/backups 表明没有执行mkdir的权限 先使用ls -al命令查看backups文件夹的权限 1drwx------ 2 root root 4096 Sep 11 11:04 backups 判断是执行实际操作的gitlab相关用户：git，没有足够的权限。依次执行以下命令 123[root@localhost_xx.xx.xx.xxx gitlab]# mkdir /var/opt/gitlab/backups[root@localhost_xx.xx.xx.xxx gitlab]# mkdir /var/opt/gitlab/backups[root@localhost_xx.xx.xx.xxx gitlab]# mkdir /var/opt/gitlab/backups 如果之前使用了 rm -rf backups 命令移除整个backups文件夹，所以需要再次mkdir。如果该文件夹已经存在，就不需要mkdir了 以上命令执行完成后，再次 ls -al，发现backups的权限已经发生改变了 1drwx------ 2 git root 4096 Sep 11 11:04 backups 再次执行backup或者restore，已经可以正常运行，问题解决。","tags":[]},{"title":"Java注解知识点","date":"2018-09-07T08:52:12.000Z","path":"2018/09/07/java/java-annotations-tips/","text":"ProcessingEnvironment源码 123456789public interface ProcessingEnvironment &#123; Map&lt;String,String&gt; getOptions(); Messager getMessager(); Filer getFiler(); Elements getElementUtils(); Types getTypeUtils(); SourceVersion getSourceVersion(); Locale getLocale();&#125; 主要方法 方法名 返回值 描述 getOptions() Map 返回指定的参数选项 getMessager() Messager 返回实现Messager接口的对象，用于报告错误信息、警告提醒 getFiler() Filer 返回实现Filer接口的对象，用于创建文件、类和辅助文件 getElementUtils() Elements 返回实现Elements接口的对象，用于操作元素的工具类 getTypeUtils() Types 返回实现Types接口的对象，用于操作类型的工具类 通过getOptions()方法获取选项参数，在gradle文件中配置选项参数值 123456789android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ version : '1.0.0' ] &#125; &#125; &#125;&#125; 通过ProcessingEnvironment去获取对应的参数 1processingEnvironment.getOptions().get(&quot;version&quot;); RoundEnvironment源码： 123456789101112public interface RoundEnvironment &#123; boolean processingOver(); boolean errorRaised(); Set&lt;? extends Element&gt; getRootElements(); Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a); Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a);&#125; 主要方法 方法名 返回值 描述 getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a) Set&lt;? extends Element&gt; 通给给定的注解，获取Element元素列表（获取注解标示的元素） Element源码： 123456789101112131415161718192021222324252627public interface Element extends javax.lang.model.AnnotatedConstruct &#123; TypeMirror asType(); ElementKind getKind(); Set&lt;Modifier&gt; getModifiers(); Name getSimpleName(); Element getEnclosingElement(); List&lt;? extends Element&gt; getEnclosedElements(); @Override boolean equals(Object obj); @Override int hashCode(); @Override List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors(); @Override &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType); &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p);&#125; 主要子类 类型 描述 PackageElement 包元素。提供对有关包及其成员的信息的访问 ExecutableElement 类、接口的方法元素。包括构造方法、注解类型 VariableElement 字段、enum、方法、构造方法参数、局部变量、资源变量、异常参数 TypeElement 类、接口元素。提供对有关类型及其成员的信息的访问 TypeParameterElement 类、接口、方法、构造方法的参数元素 主要方法 方法名 返回值 描述 getKind() ElementKind 返回此元素的种类：包、类、接口、方法、字段等 asType() TypeMirror 返回元素的数据类型（基本类型、引用类型、数组类型等等） getSimpleName() Name 返回此元素的简单名称,比如activity名 getEnclosingElement() Element 返回此元素的修饰符 getModifiers Set&lt;.Modifier&gt; 返回此元素的修饰符 getAnnotation &lt;.A. extends Annotation&gt; A 返回此元素针对指定类型的注解（如果存在这样的注解），否则返回 null。注解可以是继承的，也可以是直接存在于此元素上的 ElementKind元素的类型，元素的类型判断不需要用instanceof去判断，而应该通过Element.getKind()去判断对应的类型 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public enum ElementKind &#123; /** A package. */ PACKAGE, /** An enum type. */ ENUM, /** A class not described by a more specific kind (like &#123;@code ENUM&#125;). */ CLASS, /** An annotation type. */ ANNOTATION_TYPE, INTERFACE, ENUM_CONSTANT, FIELD, /** A parameter of a method or constructor. */ PARAMETER, /** A local variable. */ LOCAL_VARIABLE, /** A parameter of an exception handler. */ EXCEPTION_PARAMETER, // Executables /** A method. */ METHOD, /** A constructor. */ CONSTRUCTOR, /** A static initializer. */ STATIC_INIT, /** An instance initializer. */ INSTANCE_INIT, TYPE_PARAMETER, OTHER, RESOURCE_VARIABLE; public boolean isClass() &#123; return this == CLASS || this == ENUM; &#125; public boolean isInterface() &#123; return this == INTERFACE || this == ANNOTATION_TYPE; &#125; public boolean isField() &#123; return this == FIELD || this == ENUM_CONSTANT; &#125;&#125; 主要类型 属性 描述 PACKAGE 包 ENUM 枚举 CLASS 类 ANNOTATION_TYPE 注解 INTERFACE 接口 ENUM_CONSTANT 枚举常量 FIELD 字段 PARAMETER 方法参数 LOCAL_VAR 局部变量 METHOD 方法 CONSTRUCTOR 构造方法 TYPE_PARAMETER 类型参数 TypeMirror元素的数据类型，基本类型、引用类型、数组类型等等 源码： 123456789101112public interface TypeMirror extends javax.lang.model.AnnotatedConstruct &#123; TypeKind getKind(); boolean equals(Object obj); int hashCode(); String toString(); &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p);&#125; 主要子类 类型 描述 IntersectionType - UnionType - ExecutableType Executable类型(方法、构造方法、初始化) NoType 在实际类型不适合的地方使用的伪类型 PrimitiveType 基本数据类型 WildcardType 通配符类型参数 ReferenceType 引用类型 NullType Null类型 DeclaredType 声明类型(类或接口类型) ErrorType 异常类或接口类型) TypeVariable 类型变量 ClassType 类类型 ArrayType 数组类型 PackageType 包类型 AnnotatedType 注解类型 MethodType 方式类型 主要方法 方法 返回类型 描述 getKind TypeKind 返回类型的属性 TypeKind类型的属性，类型的属性判断不需要用instanceof去判断，而应该通过TypeMirror.getKind()去判断对应的属性 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public enum TypeKind &#123; BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE, VOID, NONE, NULL, ARRAY, DECLARED, ERROR, TYPEVAR, WILDCARD, PACKAGE, EXECUTABLE, OTHER, UNION, INTERSECTION; public boolean isPrimitive() &#123; switch(this) &#123; case BOOLEAN: case BYTE: case SHORT: case INT: case LONG: case CHAR: case FLOAT: case DOUBLE: return true; default: return false; &#125; &#125;&#125; 主要属性 属性 描述 BOOLEAN 基本类型booelan INT 基本类型int LONG 基本类型long FLOAT 基本类型float DOUBLE 基本类型double VOID 对应于关键字void的伪类型 NULL null类型 ARRAY 数组类型 PACKAGE 对应于包元素的伪类型 EXECUTABLE 方法、构造方法、初始化 这里需要注意的是，如果我们通过注解去获取Class类型的值，如果获取的Class未被编译，则会抛出MirroredTypeException异常，此时我们需要通过try-catch语句在catch里去获取我们所需要的类元素 123456try &#123; annotation.value();//如果value为Class类型则会报异常&#125; catch (MirroredTypeException mte) &#123; DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror(); TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();//通过异常去获取类元素&#125; FilerFiler接口支持通过注解处理器创建新文件。可以创建三种文件类型：源文件、类文件和辅助资源文件 源码： 123456789101112131415161718public interface Filer &#123; JavaFileObject createSourceFile(CharSequence name, Element... originatingElements) throws IOException; JavaFileObject createClassFile(CharSequence name, Element... originatingElements) throws IOException; FileObject createResource(JavaFileManager.Location location, CharSequence pkg, CharSequence relativeName, Element... originatingElements) throws IOException; FileObject getResource(JavaFileManager.Location location, CharSequence pkg, CharSequence relativeName) throws IOException;&#125; 方法 返回值 描述 createSourceFile JavaFileObject 创建源文件 createClassFile JavaFileObject 创建类文件 createResource FileObject 创建辅助资源文件 MessagerMessager接口提供注解处理器用来报告错误消息、警告和其他通知的方式 源码： 1234567891011121314public interface Messager &#123; void printMessage(Diagnostic.Kind kind, CharSequence msg); void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e); void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a); void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a, AnnotationValue v);&#125; 方法名 描述 printMessage 打印错误消息 参考： https://blog.csdn.net/qq_30379689/article/details/82345625","tags":[{"name":"java","slug":"java","permalink":"yzbzz.github.io/tags/java/"},{"name":"Annotation","slug":"Annotation","permalink":"yzbzz.github.io/tags/Annotation/"}]},{"title":"study-android-jitpack","date":"2018-07-09T08:54:25.000Z","path":"2018/07/09/study/study-android-jitpack/","text":"","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"Hello, Jetpack","date":"2018-07-04T03:37:01.000Z","path":"2018/07/04/android/android-jetpack-basic/","text":"Andorid JetpackJetpack是一组库、工具和构架指导，可以帮助您快速、轻松地构建优秀的Android应用程序。它们将现有的支持库和体系结构组件组合在一起，并将它们分为四类： 官网：https://developer.android.com/jetpack/ 官网示例：https://github.com/googlesamples/android-sunflower FoundationArchitectureBehaviorUIAndroid官方架构组件Paging：分页库的设计美学 Writing Better Adapters How to bind a list of items to a RecyclerView with Android Data Binding 棉花糖给 Android 带来的 Data Bindings Android Data Binding 系列(一) – 详细介绍与使用 https://blog.csdn.net/qiang_xi/article/details/75379321","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"怎么样读五线谱","date":"2018-06-20T02:55:40.000Z","path":"2018/06/20/music/music-basic-staff/","text":"最形象五线谱学习图谱 Introduction to Reading Piano Notes in 5 Easy Steps HOW TO READ SHEET MUSIC: How to Read Music 钢琴五线谱对照表 简谱 1 2 3 4 5 6 7 唱名 do re mi fa sol la si 音名 C D E F G A B 高音谱号 低音谱号 音符","tags":[{"name":"life","slug":"life","permalink":"yzbzz.github.io/tags/life/"},{"name":"music","slug":"music","permalink":"yzbzz.github.io/tags/music/"}]},{"title":"android-interview","date":"2018-06-04T06:29:08.000Z","path":"2018/06/04/android/android-interview/","text":"Android 启动模式 standard，singleTop，singleTask，singleInstance activity view window context Service的两种启动方式 Broadcast有几种 有序广播，无序广播，粘性广播，本地广播 Broadcast注册方式与区别 静态注册和动态注册 进程间通信的方式 进程基于哪些不同的状态 foreground activity visible activity service process background activity empty process 加载大图片 ANR Handler的原理 View的绘制流程 onMeasure -&gt; onLayout -&gt; onDraw View，ViewGroup事件分发 dispatchTouchEvent onInterceptTouchEvent onTouchEvent requestDisallowInterceptTouchEvent 布局优化 merge -&gt; include -&gt; viewstub activity能获取view的宽高 Parcelable与Serializable的区别 RecyclerView andriod动画 MVP ，MVC，MVVM 设计模式 HashMap和Hashtable有什么区别 Contentprovider 网络请求框架 注解与反射 sleep wait 不使用第三个变量，交换2个数 重载和重写 单例如何防止多线程 kotlin","tags":[]},{"title":"android-view","date":"2018-05-31T03:05:06.000Z","path":"2018/05/31/android/android-view/","text":"chlidLayoutParams\\parentSpecMode EXACTLY AT_MOST UNSPECIFIED dp/px EXACTLYchildSize EXACTLYchildSize EXACTLYchildSize match_parent EXACTLYparentSize AT_MOSTparentSize UNSPECIFIED0 wrap_content AT_MOSTparentSize AT_MOSTparentSize UNSPECIFIED0","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"程序人生","date":"2018-05-11T03:33:20.000Z","path":"2018/05/11/smile/smile-programmer/","text":"两程序员聊天，程序员甲抱怨：“做程序员太辛苦了，我想换行……我该怎么办？”程序员乙：“敲一下回车。” 我很奇怪客栈这个词，难道后入住的必须先退房吗？ 佛跳墙 GOD use VPN","tags":[{"name":"smile","slug":"smile","permalink":"yzbzz.github.io/tags/smile/"}]},{"title":"poetry-zen","date":"2018-05-11T03:32:27.000Z","path":"2018/05/11/poetry/poetry-zen/","text":"八苦：生、老、病、死、怨憎会、爱别离、求不得、五阴盛 无论我走到哪里，那都是我该去的地方，经历一些我该经历的事，遇见我该遇见的人 1.人笨就要多花时间学习，努力提高绩点，别听别人瞎BB。 2.人弱就要多花时间锻炼，努力提升体质，别跟别人瞎胡闹。 3.人丑就要多花时间读书，努力提高内涵，别和别人瞎攀比。 4.人蠢就要多花时间观察，努力修炼为人，别和别人瞎搅合。 5.人傻就要多花时间请教，努力开阔眼界，别和别人瞎虚混。 弟子问老师：“您能谈谈人类的奇怪之处吗？”老师答道：“他们急于成长，然后又哀叹失去的童年；他们以健康换取金钱，不久后又想用金钱恢复健康。他们对未来焦虑不已，却又无视现在的幸福。因此，他们既不活在当下，也不活在未来.他们活着仿佛从来不会死亡。临死前，又仿佛从未活过。” 卦不可算尽，畏天道无常 情不敢至深，恐大梦一场 人生如茶，第一道苦如生命，第二道香如爱情，第三道淡如清风 听过很多道理，依然过不好这一生 我们看不惯那么多人和事，却也没比别人好到哪去 你所浪费的今天，是昨天死去的人奢望的明天；你所厌恶的现在，是未来的你回不去的曾经。人生短暂，珍惜当下 人会长大三次。第一次是在发现自己不是世界中心的时候。第二次是在发现即使再怎么努力，终究还是有些事令人无能为力的时候。第三次是在，明知道有些事可能会无能为力，但还是会尽力争取的时候。 没有不可治愈的伤痛，没有不能结束的沉沦，所有失去的，会以另一种方式归来。","tags":[{"name":"poetry","slug":"poetry","permalink":"yzbzz.github.io/tags/poetry/"}]},{"title":"开心一刻","date":"2018-05-11T03:28:39.000Z","path":"2018/05/11/smile/smile-global/","text":"天将降大任于斯人也，必先收其电脑，夺其手机，断其wifi，拒其看叨叨，使其焦躁无聊，百无聊赖，便可用心上班/读书！ (然后静坐、思过、锻炼 、读书、明智、开悟、精技……) 我的兴趣爱好可分为静态和动态两种，静态就是睡觉，动态就是翻身 你打游戏时，别人在熬夜加班赶项目；你上班摸鱼时，别人在卖命拼酒陪客户；你晚上睡大觉时，别人在废寝忘食地工作；你跟女朋友出去旅游时，别人在通宵做商业计划书；这就是别人二十多岁猝死在工作岗位上而你皮肤好气色好精神好的原因。","tags":[{"name":"smile","slug":"smile","permalink":"yzbzz.github.io/tags/smile/"}]},{"title":"心灵鸡汤","date":"2018-05-11T03:17:01.000Z","path":"2018/05/11/poetry/poetry-heart/","text":"不在乎有的，不惦记没的，不害怕失去的，不追求强扭的。对得到适可而止，对失去心无畏惧 喷泉之所以漂亮是因为她有了压力；瀑布之所以壮观是因为她没有了退路；水之所以能穿石是因为永远在坚持 只要你真正努力过，再惨也不过是大器晚成 人最怕一生碌碌无为，还说平凡难能可贵 因果不虚，你昨天偷过的懒，总有一天会变成一记重重的耳光，打在你的脸上 有钱虽不意味着你想干什么就能干什么，但可以让你不想做什么就不做什么 不管我们活成了什么样子，优秀也好，平庸也罢，高贵也好，卑贱也罢，富裕也好，贫穷也罢，总会有人喜欢你，也总会有人不喜欢你。 没有钱，你拿什么维持你的亲情，稳固你的爱情，联络你的友情，靠嘴说吗，别闹了，大家都挺忙的！ 宁愿浪费3分钟或2个小时换来一句“不过如此”，也别让快进和剧透造成一点“早知当初”。 因果不虚，你昨天偷过的懒，总有一天会变成一记重重的耳光，打在你的脸上 你安逸到无法改变，成为所谓“佛系青年” 比你好看的人还比你优秀，比你优秀的人还比你努力，努力用几个月的时间做足了你一年都做不了的准备 在没有人看到的地方去努力，坚持早起、坚持学习、坚持运动，不断学习新技能，努力遇见更好的自己。 世界有2件事最难：一是把自己的知识装进别人的脑袋；二是把别人的钱装进自己的口袋 你之所以即使疲劳了，也不肯睡觉，是因为你没有勇气结束这一天，也没有勇气迎接新的一天 在为浪费时间而后悔和自责时，你依然在浪费时间。 哪有什么岁月静好，只是有人为你默默承受 当你开始变优秀的时候，连世界都会忍不住想要跟你做朋友。那些曾经想也不敢想的资源会尽数朝你倾过来，那些做梦也想不到的际遇会如雨后春笋般出现在你身旁。 上帝给你的所有东西都是明码标价的，现在你浪费青春换来的片刻安逸，未来要用半辈子的辛苦劳作去偿还。 正如我常说的，人生是一个积分，你的选择影响的绝不仅仅是你自己，还有你的孩子。今天安逸的选择或许让你的人生某个阶段更加舒适，但是往往也意味着你给孩子设置了一个本可以没有的屏障 我怕自己成功的速度赶不上父母老去的速度，或者父母已经老了而我还没有成功 不是急于求成，也不是踟蹰不前，只是朝着一个方向，慢慢地往前走着。世上没有白走的路，每走一步都算数。 目标设到月球，即使失败，也能落到众星之间。","tags":[{"name":"poetry","slug":"poetry","permalink":"yzbzz.github.io/tags/poetry/"}]},{"title":"poetry-love","date":"2018-05-11T03:13:48.000Z","path":"2018/05/11/poetry/poetry-love/","text":"如果今生我们注定擦肩而过，我能做的，惟有深深地祝福你，愿你永远快乐！然后收我所有的点点情意，期待下世再与你相逢… 就是这样一个普通女孩，一见不过尔尔，再见方觉有些可爱，最终经历千山万水走到她身边，才惊呼她魅力非凡 夜阑卧听风吹雨，铁马是你，冰河也是你 月落乌啼霜满天，江枫似卿，渔火亦似卿。 年年白发催人老，夜夜是你，青山也是你 晓看天色暮看云，行也思君，坐也思君 二斤黄酒加十年相思，才说出喜欢二字 我从未拥有过你一秒钟，心里却失去过你千万次 总有一天 你会遇见一个好姑娘 她不要你有房子 不要你有车子 不要你有钻石 更不要你的钱 也不要你。 遇见你 我变得很低很低 一直低到尘埃里去 但我的心是欢喜的 并且在那里开出一朵花来 一生会遇见两个人，一个惊艳了时光，一个温柔了岁月 一生待一人，一世一双人 那么多少轮回的眷恋才许得今生这一世姻缘！ 怎么用一句话，写出一个悲情的有诗感的爱情故事？ 系统提示：你们有67个共同朋友，是否添加她为好友？","tags":[]},{"title":"优美的英文诗句","date":"2018-05-11T02:59:14.000Z","path":"2018/05/11/poetry/poetry-english/","text":"I love three things in the world, the sun, the moon and you. The sun for day, the moon for the night, and you forever 浮世三千，吾爱有三。日，月与卿。日为朝，月为暮，卿为朝朝暮暮。 Some of us get dipped in flat, some in satin, some in gloss. But every once in a while you find someone who’s iridescent, and when you do, nothing will ever compare.(怦然心动) 有人住高楼,有人在深沟,有人光万丈,有人一身锈,世人万千种,浮云莫去求,斯人若彩虹,遇上方知有 If he likes cake, he will not like you, even if you’re the best chocolate. But always remember, to be the best of yourself, the right person will like you. 也对自己是梧桐，凤凰才会来栖，自己是大海，百川才来汇聚花香自有蝶舞来，日子没到强求又何必做全世界最棒的巧克力，你自然会碰见来自四面八方的巧克力爱好者。","tags":[{"name":"poetry","slug":"poetry","permalink":"yzbzz.github.io/tags/poetry/"}]},{"title":"Java反射","date":"2018-04-27T08:35:46.000Z","path":"2018/04/27/java/java-reflection/","text":"前言在Java中，我们主要通过反射(Reflection)来在运行时来获取类或对象的相关信息 获取对象所属的类 构造类的对象 获取类的构造函数对象 获取类的成员变量，包括private 修饰的变量 调用类的方法，包括private修饰的方法 基本运用在使用反射时，我们会先获取Class对象，再通过Class对象获取对象常用的操作类：Constructor(构造函数)、Field(字段)、Method(方法) Class类Class代表类对象，可以通过以下几种方式获取 1234567891011121314// 第一种Class&lt;?&gt; cls1 = MyClass.class;// 第二种MyClass myClass = new MyClass();Class&lt;?&gt; cls2 = myClass.getClass();// 第三种，forName方法的参数需要填完整的包名和类名Class&lt;?&gt; cls3 = null;try &#123; cls3 = Class.forName(\"reflection.MyClass\");&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; 获取类名称 12345Class&lt;?&gt; myClass = MyClass.class;// 返回类的名称(包含包名): reflection.MyClassmyClass.getName() // 返回类的名称(不包含包名): MyClassmyClass.getSimpleName() 创建实例 123Class&lt;?&gt; cls = MyClass.class;// 调用newInstance()方法获取实例对象时，类必需提供一个公有的无参数的构造函数MyClass myClass = cls.newInstance(); Class类的一些常用方法 1234// 获取父类public native Class&lt;? super T&gt; getSuperclass();// 获取实现的所有接口public Class&lt;?&gt;[] getInterfaces(); Constructor类Constructor表示类的构造器对象，可以通过以下方式获取。其中类似getDeclaredConstructor的方法返回不限修饰符的构造函数，getConstructor的方法表示只返回public修饰的构造函数 部分源码: 1234567891011// 返回公有(public修饰)构造函数对象列表，不包含除public修饰的构造函数 public Constructor&lt;?&gt;[] getConstructors();// 返回所有构造函数对象列表，不限修饰符(包含private等修饰的构造函数)public Constructor&lt;?&gt;[] getDeclaredConstructors();// 根据给定的参数类型返回构造函数，如果获取的构造函数不是public修饰的，会报NoSuchMethodExceptionpublic Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes); // 根据给定的参数类型返回不限修饰符的构造函数public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes); 示例： 12345678910111213141516171819public class MyClass &#123; public MyClass() &#123;&#125; // 第一个 public MyClass(int arg) &#123;&#125; // 第二个 protected MyClass(String arg) &#123;&#125; // 第三个 private MyClass(int arg1, String arg2) &#123;&#125; // 第四个&#125;Class&lt;?&gt; myClass = MyClass.class;// 返回公有(public修饰)构造函数对象列表，不包含除public修饰的构造函数(2个对象)Constructor[] constructors = myClass.getConstructors() // 返回所有构造函数对象列表，包含private等修饰的构造函数(4个对象)Constructor[] declaredConstructors = myClass.getDeclaredConstructors() // 报NoSuchMethodException，因为getConstructor只能获取public修饰的构造函数，这里的第四个构造是private修饰的Constructor&lt;?&gt; constructor = myClass.getConstructor(int.class, String.class);// 返回第四个构造函数Constructor&lt;?&gt; declaredConstructor = myClass.getDeclaredConstructor(int.class, String.class); 创建实例 我们可以使用newInstance方法创建实例，这里有一点要注意的是：newInstance方法需要修饰符为public的构造函数来调用，否则会创建实例时会报错。看下面的例子 123456789Class&lt;?&gt; myClass = MyClass.class;Constructor&lt;?&gt; intConstructor = myClass.getConstructor(int.class);// 正常获取，因为参数为int的构造函数的访问级别是public的MyClass myClass1 = (MyClass) intConstructor.newInstance(1);Constructor&lt;?&gt; intAndStringConstructor = myClass.getDeclaredConstructor(int.class, String.class);// 报IllegalAccessException, 因为参数为int, String的构造函数的访问级别是private的MyClass myClass2 = (MyClass) intAndStringConstructor.newInstance(1, \"hello\"); Constructor对象的一些常用方法 12345678910Constructor&lt;?&gt; constructor = myClass.getDeclaredConstructor(int.class, String.class);// 获取构造函数的访问级别(public,private等),可以调用Modifier类的一些方法(isPublic/isPrivate)来判断访问级别int modifiers = constructor.getModifiers();// 获取构造函数的参数数量int count = constructor.getParameterCount();// 获取构造函数的参数列表Parameter[] Parameteres = constructor.getParameters(); Field类Field表示类的字段对象，可以通过以下方式获取。其中类似getDeclaredField的方法返回不限修饰符的字段，getField的方法表示只返回public修饰的字段。getField会从当前类开始，一直找到最顶级的父类(Object)为止 部分源码： 1234567891011// 只返回public修饰的字段, 包括父类的字段public Field[] getFields();// 返回本类的所有字段(不包括父类)，不限修饰符public Field[] getDeclaredFields();// 通过给定的字段名称(包括父类)，获取Field对象，如果字段名称不存在或Field对象不是public修饰的，会报NoSuchFieldExceptionpublic Field getField(String name);// 通过给定的字段名称(不包括父类)，获取不限修饰符的字段public Field getDeclaredField(String name) 示例： 1234567891011121314151617181920212223public class FatherClass &#123; public String fatherName = \"fatherName\";&#125;public class MyClass extends FatherClass &#123; public static String TAG = \"tag\"; public int age; protected String name; private String address;&#125;Class&lt;?&gt; myClass = MyClass.class;// 只返回public修饰的字段(TAG, age, fatherName), 包括父类的public字段。FatherClass继承至Object，但Object没有字段，所以只会返回MyClass和FatherClass的所有public字段Field[] fields = myClass.getFields();// 返回本类的所有字段(不包括父类)，不限修饰符(TAG, age, name ,address)Field[] declaredFields = myClass.getDeclaredFields();// 报NoSuchFieldException，因为address字段是private修饰的Field addressField = myClass.getField(\"address\");// 通过给定的字段名称，获取Field对象，返回address字段对象Field addressDeclaredField = myClass.getDeclaredField(\"address\"); Field一些常用的方法 Field提供了get/set方法用于获取、设置字段的值。同时提供了基本数据类型的get/set方法，用于简化操作。下面是截取的Field类的部分代码 Get/Set方法 1234567891011121314151617// get方法public native Object get(Object obj) // 基本数据类的get方法public native boolean getBoolean(Object obj)public native byte getByte(Object obj)public native char getChar(Object obj)public native int getInt(Object obj)public native double getDouble(Object obj)... // set方法public native void set(Object obj, Object value)// 基本数据类的set方法public native void setBoolean(Object obj, boolean z)public native void setInt(Object obj, int i)public native void setDouble(Object obj, double d)... 需要注意的是 1.对于非静态字段来说，调用get/set方法，Object参数需要传实例对象。对于静态字段来说，可以传实例对象，也可以传null，因为实例对象对静态字段来说，没有意义。 2.对于非公有字段(private/protected)等，在进行访问的时候需要先调用Field类的setAccessible(true) 示例 1234567891011121314151617181920212223Class&lt;?&gt; myClass = MyClass.class;MyClass cls = (MyClass) myClass.newInstance();// 对于静态字段Field tagFiled = myClass.getDeclaredField(\"TAG\");// 下面的代码是等价的String tag1 = (String) tagFiled.get(null);String tag2 = (String) tagFiled.get(cls);// 对于public修改的字段Field ageFiled = myClass.getDeclaredField(\"age\");// 对于get, 下面的代码是等价的int age1 = (int) ageFiled.get(cls);int age2 = ageFiled.getInt(cls); // 对于set, 下面的代码是等价的ageFiled.setInt(cls, 3);ageFiled.set(cls, 5);// 对于private修饰的字段Field addressFiled = myClass.getDeclaredField(\"address\");// 需要先调用addressFiled.setAccessible(true)，否则会报IllegalAccessException，因为address字段是private修饰的addressFiled.setAccessible(true);String address = (String) addressFiled.get(cls); 其它方法 12345678// 返回字段的访问级别(public/private等)，可以通过Modifier类来进行一些操作public int getModifiers()// 返回字段的名称public String getName()// 返回字段的类型(int, String, double等)public Class&lt;?&gt; getType()// 返回字段所在的类public Class&lt;?&gt; getDeclaringClass() Method类Method表示类的方法对象，可以通过以下方式获取。和Constructor/Field相似，提供getDeclaredMethod的方法返回不限修饰符的方法，getMethod的方法表示只返回public修饰的方法。getMethod会从当前类开始，一直找到最顶级的父类(Object)为止 部分源码： 1234567891011// 只返回public修饰的方法, 包括父类的方法public Method[] getMethods();// 返回本类的所有方法(不包括父类)，不限修饰符public Method[] getDeclaredMethods();// 通过给定的方法名称和参数类型(包括父类)，获取Method对象，如果找不到方法或Method对象不是public修饰的，会报NoSuchMethodExceptionpublic Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 通过给定的方法名称(不包括父类)，获取不限修饰符的Method对象public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142public class MyClass &#123; public int getAge() &#123; return 1; &#125; private String getName() &#123; return \"张三\"; &#125; public String getSomething(String something) &#123; return something; &#125; public static String getAddress() &#123; return \"北京\"; &#125; private void excuteCommand(String command) &#123; if (command.equals(\"1\")) &#123; System.out.println(\"执行命令1\"); &#125; else if (command.equals(\"2\")) &#123; System.out.println(\"执行命令2\"); &#125; else &#123; System.out.println(\"找不到命令\"); &#125; &#125;&#125;Class&lt;?&gt; myClass = MyClass.class;// 不仅会返回本类的public方法，还会返回Object类的public方法，因为MyClass是继承Object类的Method[] methods = myClass.getMethods();// 返回本类的所有方法(getAge, getName, getAddress)，不限修饰符Method[] declaredMethods = myClass.getDeclaredMethods();// 通过给定的方法名称和参数类型，获取Method对象Method ageMethod = myClass.getMethod(\"getAge\", null);Method notifyMethod = myClass.getMethod(\"notify\", null);Method somethingMethod = myClass.getMethod(\"getSomething\", String.class);// 报NoSuchMethodException，因为getName方法是private修饰的Method nameMethod = myClass.getMethod(\"getName\", null); Method类的一些常用方法 Method类提供invoike方法，来执行方法 源码： 1public Object invoke(Object obj, Object... args) 和Field类似，对于非public修饰的方法，需要先调用setAccessible(true) 示例： 12345678Class&lt;?&gt; myClass = MyClass.class;MyClass cls = (MyClass) myClass.newInstance();Method commandMethod = myClass.getDeclaredMethod(\"excuteCommand\", String.class);// 需要先调用commandMethod.setAccessible(true)，否则会报IllegalAccessException，因为excuteCommand方法是private修饰的commandMethod.setAccessible(true);commandMethod.invoke(cls, \"1\"); // 执行命令1commandMethod.invoke(cls, \"3\"); // 找不到命令 其它常用方法 123456789101112// 返回方法的访问级别(public/private等)，可以通过Modifier类来进行一些操作public int getModifiers()// 返回方法的名称public String getName()// 返回方法的返回类型(void, int, String, double等)public Class&lt;?&gt; getReturnType()// 返回方法所在的类public Class&lt;?&gt; getDeclaringClass()// 返回参数列表的类型数组public Class&lt;?&gt;[] getParameterTypes()// 返回参数列表数量public int getParameterCount()","tags":[{"name":"java","slug":"java","permalink":"yzbzz.github.io/tags/java/"}]},{"title":"Java 注解处理器(Annotation Processor)","date":"2018-04-18T10:48:52.000Z","path":"2018/04/18/java/java-annotations-processor/","text":"前言注解处理器(Annotation Processor Tool)是javac的一个工具，主要用于在编译时处理编译时注解RetentionPolicy.CLASS）。我们可以自定义注解处理器，获取我们自定义的注解信息，通过注解信息生成java文件(如： ButterKnife)或进行其它的一些操作 自定义注解处理器自定义注解处理器需要继承于AbstractProcessor，一般我们会重写下面4个方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class IRouterProcessor extends AbstractProcessor &#123; private Messager messager; // Log 日志 private Elements elementUtils; // 操作Element工具类 private Filer filer; // 支持通过注解处理器创建新文件 private Map&lt;String, String&gt; options; // 额外配置参数 @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); messager = processingEnvironment.getMessager(); elementUtils = processingEnvironment.getElementUtils(); filer = processingEnvironment.getFiler(); options = processingEnvironment.getOptions(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); types.add(IRouter.class.getCanonicalName()); return types; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; Set&lt;? extends Element&gt; routerElements = roundEnv.getElementsAnnotatedWith(IRouter.class); try &#123; if (null != routerElements &amp;&amp; !routerElements.isEmpty()) &#123; parseRoutes(routerElements); &#125; &#125; catch (IOException e) &#123; &#125; return true; &#125; private void parseRoutes(Set&lt;? extends Element&gt; routerElements) throws IOException &#123; for (Element element : routerElements) &#123; TypeElement typeElement = (TypeElement) element.getEnclosingElement(); TypeMirror mirror = element.asType(); ElementKind kind = element.getKind(); Name name = element.getSimpleName(); &#125; &#125;&#125; init(ProcessingEnvironment env): 每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。ProcessingEnviroment提供很多有用的工具类Elements, Types和Filer。后面我们将看到详细的内容。 process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) : 这相当于每个处理器的主函数main()。你在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。后面我们将看到详细的内容。 getSupportedAnnotationTypes(): 这里你必须指定，这个注解处理器是注册给哪个注解的。注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。换句话说，你在这里定义你的注解处理器需要处理哪些注解。 getSupportedSourceVersion(): 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。然而，如果你有足够的理由只支持Java 6的话，你也可以返回SourceVersion.RELEASE_6。我推荐你使用前者。 在Java 7中，你也可以使用注解来代替getSupportedAnnotationTypes()和getSupportedSourceVersion()，像这样： 123456789101112@SupportedSourceVersion(SourceVersion.latestSupported())@SupportedAnnotationTypes(&#123; // 合法注解全名的集合 &#125;)public class IRouterProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment env)&#123; &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment env) &#123;&#125;&#125; 因为兼容的原因，特别是针对Android平台，我建议使用重载getSupportedAnnotationTypes()和getSupportedSourceVersion()方法代替@SupportedAnnotationTypes和 @SuppozrtedSourceVersion 接下来的你必须知道的事情是，注解处理器是运行它自己的虚拟机JVM中。是的，你没有看错，javac启动一个完整Java虚拟机来运行注解处理器。这对你意味着什么？你可以使用任何你在其他java应用中使用的的东西。使用guava。如果你愿意，你可以使用依赖注入工具，例如dagger或者其他你想要的类库。但是不要忘记，即使是一个很小的处理，你也要像其他Java应用一样，注意算法效率，以及设计模式。 注册你的处理器 你可能会问，我怎样将处理器IRouterProcessor注册到javac中。你必须提供一个.jar文件。就像其他.jar文件一样，你打包你的注解处理器到此文件中。并且，在你的jar中，你需要打包一个特定的文件javax.annotation.processing.Processor到META-INF/services路径下。所以，你的.jar文件看起来就像下面这样： IRouterProcessor.jar – com – – example – – – IRouterProcessor.class – META-INF – – services – – – javax.annotation.processing.Processor 打包进IRouterProcessor.jar中的javax.annotation.processing.Processor的内容是，注解处理器的合法的全名列表，每一个元素换行分割： 123com.example.IRouterProcessor com.foo.OtherProcessor net.blabla.SpecialProcessor 把IRouterProcessor.jar放到你的builpath中，javac会自动检查和读取javax.annotation.processing.Processor中的内容，并且注册IRouterProcessor作为注解处理器。 使用@AutoService注册你的处理器 如果你觉得上面一步注册你的处理器比较麻烦的话，可以下载google的auto-server包 1implementation &apos;com.google.auto.service:auto-service:1.0-rc4&apos; 在你的注解器上加上@AutoService(Processor.class)，这样你就可以忽略上一步的注册你的处理器章节，以下是完整的类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@AutoService(Processor.class)public class IRouterProcessor extends AbstractProcessor &#123; private Messager messager; // Log 日志 private Elements elementUtils; // 操作Element工具类 private Filer filer; // 支持通过注解处理器创建新文件 private Map&lt;String, String&gt; options; // 额外配置参数 @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); messager = processingEnvironment.getMessager(); elementUtils = processingEnvironment.getElementUtils(); filer = processingEnvironment.getFiler(); options = processingEnvironment.getOptions(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); types.add(IRouter.class.getCanonicalName()); return types; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; Set&lt;? extends Element&gt; routerElements = roundEnv.getElementsAnnotatedWith(IRouter.class); try &#123; if (null != routerElements &amp;&amp; !routerElements.isEmpty()) &#123; parseRoutes(routerElements); &#125; &#125; catch (IOException e) &#123; &#125; return true; &#125; private void parseRoutes(Set&lt;? extends Element&gt; routerElements) throws IOException &#123; for (Element element : routerElements) &#123; TypeElement typeElement = (TypeElement) element.getEnclosingElement(); TypeMirror mirror = element.asType(); ElementKind kind = element.getKind(); Name name = element.getSimpleName(); &#125; &#125;&#125; 这样，编译时就会执行process方法，在这个方法里，你可以写自己的逻辑，生成java文件等等","tags":[{"name":"java","slug":"java","permalink":"yzbzz.github.io/tags/java/"},{"name":"Annotation","slug":"Annotation","permalink":"yzbzz.github.io/tags/Annotation/"}]},{"title":"Java 编译时注解(RetentionPolicy.CLASS)","date":"2018-04-13T08:07:56.000Z","path":"2018/04/13/java/java-annotation-class/","text":"前言对于编译时注解RetentionPolicy.CLASS，我们需要自定义注解处理器，参照Java 注解处理器(Annotation Processor)。 定义编译时注解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@AutoService(Processor.class)public class IRouterProcessor extends AbstractProcessor &#123; private Messager messager; private Elements elementUtils; private Filer filer; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); messager = processingEnv.getMessager(); elementUtils = processingEnv.getElementUtils(); // 支持通过注解处理器创建新文件 filer = processingEnv.getFiler(); &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); types.add(IRouter.class.getCanonicalName()); return types; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; Set&lt;? extends Element&gt; routerElements = roundEnv.getElementsAnnotatedWith(IRouter.class); try &#123; if (null != routerElements &amp;&amp; !routerElements.isEmpty()) &#123; parseRoutes(routerElements); &#125; &#125; catch (IOException e) &#123; &#125; return true; &#125; private void parseRoutes(Set&lt;? extends Element&gt; routerElements) throws IOException &#123; for (Element element : routerElements) &#123; TypeElement typeElement = (TypeElement) element.getEnclosingElement(); TypeMirror mirror = element.asType(); ElementKind kind = element.getKind(); Name name = element.getSimpleName(); &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"yzbzz.github.io/tags/java/"},{"name":"Annotation","slug":"Annotation","permalink":"yzbzz.github.io/tags/Annotation/"}]},{"title":"Java 运行时注解(RetentionPolicy.RUNTIME)","date":"2018-04-13T08:07:34.000Z","path":"2018/04/13/java/java-annotation-runtime/","text":"前言对于运行时注解RetentionPolicy.RUNTIME，我们可以通过反射的方式来获取注解的相关信息。根据注解中的Target，我们可以从Constructor、CLASS、Field、Method获取注解对象，基本方法都差不多。 Target 获取Annotation 描述 ElementType.TYPE Class&lt;?&gt;. getAnnotation() 通过Class对象获取注解 ElementType.CONSTRUCTOR Constructor.getAnnotation() 通过Constructor对象获取注解 ElementType.FIELD Field.getAnnotation() 通过Field对象获取注解 ElementType.METHOD Method.getAnnotation() 通过Method对象获取注解 … … … 一些常见的获取注解的方法 123456789101112131415161718192021222324/** * 获取指定类型的注解 */public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType);/** * 获取所有注解，如果有的话 */public Annotation[] getAnnotations();/** * 获取所有注解，忽略继承的注解 */public Annotation[] getDeclaredAnnotations();/** * 指定注解是否存在该元素上，如果有则返回true，否则false */public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationType);/** * 获取Method中参数的所有注解 */public Annotation[][] getParameterAnnotations(); 定义运行时注解自定义注解 12345678910111213141516171819202122232425262728// 适用于类、接口(包含注解类型)或enum@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface ClassAnnotation &#123; String value();&#125;// 适用于构造函数@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.CONSTRUCTOR)public @interface ConstructorAnnotation &#123; int id(); String value();&#125;// 适用于字段(包含enum实例)@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface FiledAnnotation &#123; int[] value();&#125;// 适用于方法@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MethodAnnotation &#123; String value();&#125; 在注解中定义成员(属性)时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组(下面例子中的int id()、String value())。注解中成员(属性)可以有默认值，默认值需要用 default 关键值指定。 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.CONSTRUCTOR)public @interface ConstructorAnnotation &#123; int id() default 0; String value() default \"ConstructorAnnotation\";&#125; 如何使用 12345678910111213141516171819202122@ClassAnnotation(\"this is class annotation\")public class TestAnnotation &#123; @ConstructorAnnotation(id = 1, value = \"this is constructor annotation\") public TestAnnotation() &#123; &#125; @ConstructorAnnotation public TestAnnotation(int id, String msg) &#123; &#125; @FiledAnnotation(&#123; 1, 2 &#125;) public int id = 1; @FiledAnnotation(3) public String field = \"field\"; @MethodAnnotation(\"this is method annotation\") public String method() &#123; return \"method\"; &#125;&#125; 注解赋值的方式是在注解的括号内以value=””形式，多个属性之前用,隔开。如果希望使用注解的默认值，可以像以述例子中一样直接使用@ConstructorAnnotation或@ConstructorAnnotation() 1234567@ConstructorAnnotationpublic TestAnnotation(int id, String msg) &#123;&#125;==&gt;@ConstructorAnnotation()public TestAnnotation(int id, String msg) &#123;&#125; 如果注解只包含一个成员，并且成员定义的名称为value()，则可以省略value关键字 例如上面定义的FiledAnnotation和MethodAnnotation，都使用了value()名称 123456public @interface FiledAnnotation &#123; int[] value();&#125;public @interface MethodAnnotation &#123; String value();&#125; 则可以省略value关键字，下面的调用方式是等同的 1234567891011121314151617// 对于字段@FiledAnnotation(value = &#123; 1, 2 &#125;)public int id = 1;==&gt;@FiledAnnotation(&#123; 1, 2 &#125;)public int id = 1;// 对于方法@MethodAnnotation(value = \"this is method annotation\")public String method() &#123; return \"method\";&#125;==&gt;@MethodAnnotation(\"this is method annotation\")public String method() &#123; return \"method\";&#125; 如果注解包含多个成员，并且成员都有默认值，并且有一个成员名称定义为value，则可以像下面这样简化调用 123456789@Retention(RetentionPolicy.RUNTIME)public @interface ContentType &#123; String type() default \"\"; String value() default \"\";&#125;==&gt;@ContentType(\"UI\")public class UIFragment &#123;&#125; 对于上面这种情况，ContentType注解的type会使用默认值&quot;&quot;，value的值为上面定义的UI 获取运行时注解信息因为我们定义的是RetentionPolicy.RUNTIME的注解，所以我们可以在运行时拿到注解的信息(需要反射获取) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 获取@ClassAnnotation的信息public static void printClassAnnotation(Class&lt;?&gt; clazz) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"Class注解:\"); ClassAnnotation classAnnotation = clazz .getAnnotation(ClassAnnotation.class); if (null != classAnnotation) &#123; sb.append(\"\\n\\t类名: \"); sb.append(Modifier.toString(clazz.getModifiers())).append(\" \") .append(clazz.getSimpleName()); sb.append(\"\\n\\t注解值: \").append(classAnnotation.value()); &#125; System.out.println(sb.toString());&#125;// 获取ConstructorAnnotation的信息public static void printConstructorAnnotation(Class&lt;?&gt; clazz) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"Constructor注解:\"); Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); for (Constructor&lt;?&gt; constructor : constructors) &#123; ConstructorAnnotation constructorAnnotation = constructor .getAnnotation(ConstructorAnnotation.class); sb.append(\"\\n\\t构造函数名: \"); sb.append(Modifier.toString(constructor.getModifiers())).append(\" \") .append(constructor.getClass().getSimpleName()); sb.append(\"\\n\\t构造函数参数: \"); Parameter[] parameters = constructor.getParameters(); for (Parameter parameter: parameters) &#123; sb.append(\"\\n\\t\\t\"); sb.append(parameter.getType().getSimpleName()).append(\" \") .append(parameter.getName()); &#125; sb.append(\"\\n\\t注解值: \") .append(\"\\n\\t\\tid: \" + constructorAnnotation.id()) .append(\"\\n\\t\\tvalue: \" + constructorAnnotation.value()); sb.append(\"\\n\\t---------------\"); &#125; System.out.println(sb.toString());&#125;// 获取@FieldAnnotation的信息public static void printFieldAnnotation(Class&lt;?&gt; clazz) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"Filed注解:\"); Field[] fields = clazz.getFields(); for (Field field : fields) &#123; FiledAnnotation filedAnnotation = field .getAnnotation(FiledAnnotation.class); if (null != filedAnnotation) &#123; sb.append(\"\\n\\t字段名: \"); sb.append(Modifier.toString(field.getModifiers())).append(\" \") .append(field.getType().getSimpleName()).append(\" \") .append(field.getName()); sb.append(\"\\n\\t注解值: \").append( Arrays.toString(filedAnnotation.value())); &#125; &#125; System.out.println(sb.toString());&#125;// 获取@MethodAnnotation的信息public static void printMethodAnnotation(Class&lt;?&gt; clazz) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"Method注解:\"); Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; MethodAnnotation methodAnnotation = method .getAnnotation(MethodAnnotation.class); if (null != methodAnnotation) &#123; sb.append(\"\\n\\t方法名: \"); sb.append(Modifier.toString(method.getModifiers())).append(\" \") .append(method.getReturnType().getSimpleName()).append(\" \") .append(method.getName()); sb.append(\"\\n\\t注解值: \").append(methodAnnotation.value()); &#125; &#125; System.out.println(sb.toString());&#125; 输出如下信息===&gt; 1234567891011121314151617181920212223242526Class注解: 类名: public TestAnnotation 注解值: this is class annotationConstructor注解: 构造函数名: public Constructor 构造函数参数: 注解值: id: 1 value: this is constructor annotation --------------- 构造函数名: public Constructor 构造函数参数: int arg0 String arg1 注解值: id: 0 value: ConstructorAnnotation ---------------Filed注解: 字段名: public int id 注解值: [1, 2] 字段名: public String field 注解值: [3]Method注解: 方法名: public String method 注解值: this is method annotation","tags":[{"name":"java","slug":"java","permalink":"yzbzz.github.io/tags/java/"},{"name":"Annotation","slug":"Annotation","permalink":"yzbzz.github.io/tags/Annotation/"}]},{"title":"Java 源码注解(RetentionPolicy.SOURCE)","date":"2018-04-13T08:00:56.000Z","path":"2018/04/13/java/java-annotations-source/","text":"前言通过之前的文章Java 注解介绍，我们了解到源码注解(RetentionPolicy.SOURCE)的生命周期只存在Java源文件这一阶段，是3种生命周期中最短的注解。当在Java源程序上加了一个注解，这个Java源程序要由javac去编译，javac把java源文件编译成.class文件，在编译成class时会把Java源程序上的源码注解给去掉。需要注意的是，在编译器处理期间源码注解还存在，即注解处理器Processor 也能处理源码注解，编译器处理完之后就没有该注解信息了。 定义源码注解在Android中，我们经常会用到下拉刷新的功能，通常会有四种状态 PULL_FROM_START：下拉刷新 PULL_FROM_END：上拉加载 BOTH：同时设置下拉刷新和上拉加载 DISABLED：禁用下拉刷新和上拉加载 为了限制程序只能使用上面4种状态，我们一般会定义一个Enum枚举作为参数，这样就能限定参数的取值范围 123456789101112131415161718192021222324252627public class PullToRefresh &#123; private Mode mMode = Mode.PULL_FROM_START; public void setMode(Mode mode) &#123; mMode = mode; &#125; public Mode getMode() &#123; return mMode; &#125; public void doSomething() &#123; if (mMode == Mode.PULL_FROM_START) &#123; &#125; else if (mMode == Mode.PULL_FROM_END) &#123; &#125; else if (mMode == Mode.BOTH) &#123; &#125; else if (mMode == Mode.DISABLED) &#123; &#125; &#125; public enum Mode &#123; PULL_FROM_START, PULL_FROM_END, BOTH, DISABLED &#125;&#125;// 通过以下的方式调用PullToRefresh pullToRefresh = new PullToRefresh();pullToRefresh.setMode(Mode.BOTH); 根据google官网的描述，使用枚举会比常量占用更多的内存。这个时候我们就可以自己定义一个注解来处理上面的问题 1234567891011121314151617181920212223242526272829303132333435public class PullToRefresh &#123; public static final int PULL_FROM_START = 1; public static final int PULL_FROM_END = 2; public static final int BOTH = 3; public static final int DISABLED = 4; private static int sMode = PULL_FROM_START; public void setMode(@Mode int mode) &#123; sMode = mode; &#125; public int getMode() &#123; return sMode; &#125; public void doSomething() &#123; if (sMode == PULL_FROM_START) &#123; &#125; else if (sMode == PULL_FROM_END) &#123; &#125; else if (sMode == BOTH) &#123; &#125; else if (sMode == DISABLED) &#123; &#125; &#125; @Retention(RetentionPolicy.SOURCE) @Target(ElementType.PARAMETER) @IntDef(&#123;PULL_FROM_START,PULL_FROM_END,BOTH,DISABLED&#125;) public @interface Mode &#123; &#125;&#125;// 通过以下的方式调用PullToRefresh pullToRefresh = new PullToRefresh();pullToRefresh.setMode(PullToRefresh.BOTH); 其中的@IntDef为Android提供的源码注解，用于表示取值范围，在android.support.annotation包下 123456789@Retention(RetentionPolicy.SOURCE)@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)public @interface IntDef &#123; /** Defines the allowed constants for this element */ long[] value() default &#123;&#125;; /** Defines whether the constants can be used as a flag, or just as an enum (the default) */ boolean flag() default false;&#125; 类似的还有@StringDef 123456@Retention(RetentionPolicy.SOURCE)@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)public @interface StringDef &#123; /** Defines the allowed constants for this element */ String[] value() default &#123;&#125;;&#125; 结束语总的来说，了解了源码注解，我们可以更规范的写代码，避免的很多问题的发生","tags":[{"name":"java","slug":"java","permalink":"yzbzz.github.io/tags/java/"},{"name":"Annotation","slug":"Annotation","permalink":"yzbzz.github.io/tags/Annotation/"}]},{"title":"Java 注解介绍","date":"2018-04-12T10:09:35.000Z","path":"2018/04/12/java/java-annotations/","text":"[TOC] 本文及相关注解文章部分摘自以下的博客，推荐大家阅读 秒懂，Java 注解 （Annotation）你可以这样学 Java注解基础概念总结 定义注解(Annotaion)，也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注解。 作用分类： 编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】。 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】。 编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查【Override】。 语法示例： 12345678910// 定义一个注解@Retention(RetentionPolicy.CLASS)@Target(ElementType.TYPE)public @interface AnnotationsTest &#123; String value ();&#125;// 使用@AnnotationsTest(value = \"abc\")class Foo &#123;&#125; 以@interface关键字定义 注解包含成员，成员以无参数的方法的形式被声明。其方法名和返回值定义了该成员的名字和类型，例如上述例子中的String value() 成员赋值是通过@Annotation(name=value)的形式，例如上述例子中的@Target(ElementType.TYPE) 注解需要标明注解的生命周期，注解的修饰目标等信息，这些信息是通过元注解实现 下面我们来分析一下java.lang.annotation中定义的Target注解： 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125; 元注解@Retention，成员value的值为RetentionPolicy.RUNTIME 元注解@Target，成员value是个数组，用{}形式赋值，值为ElementType.ANNOTATION_TYPE 成员名称为value，类型为ElementType[] 另外，需要注意一下，如果成员名称是value，在赋值过程中可以简写。如果成员类型为数组，但是只赋值一个元素，则也可以简写。如上面的简写形式为： 12@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE) 注解的类型注解分为两类，一类是元注解(meta-annotation)，另外一类是普通注解 元注解 所谓元注解就是修饰注解的注解。拿到一个注解，如何知道它是否是元注解呢？需要看它的元注解（无论是元注解还是普通注解都是有元注解），如果看到这样的元注解：@Target(ElementType.ANNOTATION_TYPE)，那么此时这个注解一定是元注解。 @Retention 表示在什么级别保存该注解信息，可能的值在枚举类ElementType中 1234567891011121314151617@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125;// RetentionPolicypublic enum RetentionPolicy &#123; SOURCE, // 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃 CLASS, // 注解被保留到class文件，jvm加载class文件时候被遗弃。这是默认的生命周期 /* * 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在，保存到class对象中， * 可以通过反射来获取 */ RUNTIME &#125; 这3个生命周期对应表如下 名称 生命周期 RetentionPolicy.SOURCE Java源文件(.java文件) RetentionPolicy.CLASS .class文件 RetentionPolicy.RUNTIME 内存中的字节 首先要明确生命周期长度 SOURCE &lt; CLASS &lt; RUNTIME ，所以前者能作用的地方后者一定也能作用。一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME注解；如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；如果只是做一些检查性的操作，比如@Override 和 @SuppressWarnings，则可选用 SOURCE 注解。 @Target 表示该注解用于什么地方，可能的值在枚举类ElementType中 12345678910111213141516171819@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125;public enum ElementType &#123; TYPE, // 类、接口(包含注解类型)或enum声明 FIELD, // 字段声明(包含enum实例) METHOD, // 方法声明 PARAMETER, // 参数声明 CONSTRUCTOR, // 构造器声明 LOCAL_VARIABLE, // 局部变量声明 ANNOTATION_TYPE, // 注解声明 PACKAGE, // 包声明 TYPE_PARAMETER, // 泛型参数声明 (自1.8提供) TYPE_USE, // 泛型声明 (自1.8提供)&#125; @Documented 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125; @Inherited 允许子类继承父类中的注解 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125; @Repeatable @Repeatable 是 Java 1.8 才加的，意为可重复，也就是注解的值可以同时取多个 示例，一个人 普通注解基本内置注解@Override 该注解提示子类复写父类中的方法 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; @Deprecated 这注解用来标记过时的元素。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素（过时的方法、过时的类、过时的成员变量） 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; @SuppressWarnings 阻止警告的意思。之前说过调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。 12345@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 自定义注解关于自定义注解，请移步 java 自定义源码注解 java 自定义编译时注解 java 自定运行时注解","tags":[{"name":"java","slug":"java","permalink":"yzbzz.github.io/tags/java/"},{"name":"Annotation","slug":"Annotation","permalink":"yzbzz.github.io/tags/Annotation/"}]},{"title":"Android 自定义注解","date":"2018-04-11T09:56:24.000Z","path":"2018/04/11/android/android-customer-annotations/","text":"新建一个module，选择Java Library auto-service：Google 公司出品，用于自动为 JAVA Processor 生成 META-INF 信息。 AutoService注解处理器是Google开发的，用来生成 META-INF/services/javax.annotation.processing.Processor 文件的，你只需要在你定义的注解处理器上添加 @AutoService(Processor.class) 就可以了，简直不能再方便了。","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"多图详解咖啡种类","date":"2018-04-10T10:28:26.000Z","path":"2018/04/10/life/life-coffee/","text":"原文:秒懂咖啡！一张图看懂拿铁、卡布奇诺、玛奇朵、摩卡的区别！ 虽然咖啡的种类很多，但无非就是浓缩咖啡与牛奶、糖、奶泡和奶油之间的排列组合，而在保证基本组合的情况下， 加入不同的配料，又成了更加细分的咖啡。比如抹茶拿铁，就是在拿铁的基础上加入了抹茶粉。本文所有的咖啡种类， 均已最初的意式咖啡为主，在实际制作中，不同咖啡店可能会有自己的改良。","tags":[{"name":"life","slug":"life","permalink":"yzbzz.github.io/tags/life/"}]},{"title":"android-view-textview","date":"2018-04-10T08:33:20.000Z","path":"2018/04/10/android/android-view-textview/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PartiallyClickableActivity extends AppCompatActivity &#123; private TextView tv; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.partially_clickable_activity); tv = (TextView) findViewById(R.id.tv); //step1 设置点击背景色为透明 tv.setHighlightColor(getResources().getColor(android.R.color.transparent)); String st1 = \"产品成立、计息并进封入闭期。购买成功后1-2个交易日可通过\"; String st2 = \"【我的理财】\"; //step3 设置SpannableString SpannableString info = new SpannableString(st1 + st2 ); info.setSpan(new ForegroundColorSpan(Color.BLACK), 0, st1.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); info.setSpan(new ForegroundColorSpan(Color.RED), st1.length(), (st1 + st2).length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); info.setSpan(new Clickable(clickListener), st1.length(), (st1 + st2).length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | ~Spanned.SPAN_MARK_MARK); //step4 TextView设置SpannableString tv.setText(info); tv.setMovementMethod(LinkMovementMethod.getInstance()); &#125; private View.OnClickListener clickListener = new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(PartiallyClickableActivity.this, \"点击成功....【我的理财】\", Toast.LENGTH_SHORT).show(); &#125; &#125;; //step2 定义ClickableSpan class Clickable extends ClickableSpan &#123; private final View.OnClickListener mListener; public Clickable(View.OnClickListener l) &#123; mListener = l; &#125; @Override public void onClick(View v) &#123; mListener.onClick(v); &#125; @Override public void updateDrawState(TextPaint ds) &#123; //取消下滑线 ds.setUnderlineText(false);// super.updateDrawState(ds); &#125; &#125;&#125;","tags":[]},{"title":"program-blog","date":"2018-03-30T07:49:15.000Z","path":"2018/03/30/blogs/program-blog/","text":"程序员的艺术：排序算法舞蹈 51VOA美国之音 如何使用Android MediaStore裁剪大图片 Android KEYCODE列表","tags":[{"name":"blog","slug":"blog","permalink":"yzbzz.github.io/tags/blog/"}]},{"title":"Ubuntu开启BBR","date":"2018-03-30T03:02:35.000Z","path":"2018/03/30/study/study-ubuntu-bbr/","text":"原文地址：Ubuntu开启BBR加速Shadowsocks 升级内核ubuntu开启BBR加速需要内核高于4.9，先检查内核版本: 1uname -a 如果版本高于4.9，那就可以直接开启BBR，否则需要先升级内核（需要root权限） 1.首先查看系统是32位还是64位 1getconf LONG_BIT 2.去官网最新的程序包，这里以v4.15/为例 1wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.15/linux-image-4.15.0-041500-generic_4.15.0-041500.201802011154_amd64.deb 3.执行下面的命令进行升级 1dpkg -i linux-image-4.15.0-041500-generic_4.15.0-041500.201802011154_amd64.deb 4.更新grub引导装入程序 1update-grub 5.重启机器 1reboot 重启后查看自己的内核版本就会发现更新到4.15了 开启TCP BBR加速1.修改系统变量 12echo \"net.core.default_qdisc=fq\" &gt;&gt; /etc/sysctl.confecho \"net.ipv4.tcp_congestion_control=bbr\" &gt;&gt; /etc/sysctl.conf 如查执行上述命令时显示拒绝访问，则可以尝试使用如下命令： 12sudo bash -c 'echo \"net.core.default_qdisc=fq\" &gt;&gt; /etc/sysctl.conf'sudo bash -c 'echo \"net.ipv4.tcp_congestion_control=bbr\" &gt;&gt; /etc/sysctl.conf' 2.保存生效 1sysctl -p 3.查看是否开启成功 1sysctl net.ipv4.tcp_available_congestion_control 如果返回:net.ipv4.tcp_available_congestion_control = reno cubic bbr，那么表示BBR开启成功 也可以执行lsmod | grep bbr来查看是否开启成功","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"study-ubuntu-nextcloud","date":"2018-03-23T03:53:01.000Z","path":"2018/03/23/study/study-ubuntu-nextcloud/","text":"1234sudo apt-get updatesudo apt-get install snapsudo apt-get install snapdsudo snap install nextcloud 加密 1sudo nextcloud.enable-https lets-encrypt","tags":[]},{"title":"kotlin-tips","date":"2018-03-19T11:38:52.000Z","path":"2018/03/19/android/kotlin-tips/","text":"12345678910fun &lt;T&gt; test() : T &#123; when(T)&#123; // this won't work perhaps T::something? is Int -&gt; &#123; ........ ==&gt; inline fun &lt;reified T&gt; test() : T &#123; when (T::class) &#123; Int::class -&gt; println(\"Int\") else -&gt; println(\"$&#123;T::class&#125;\")","tags":[]},{"title":"Kotlin详解集合与操作符","date":"2018-03-14T02:06:08.000Z","path":"2018/03/14/android/kotlin-collections/","text":"[TOC] 前言kotlin的集合分为不可变集合和可变集合 Kotlin 的 List&lt;out T&gt; 只提供只读操作如 size、get等的接口。和 Java 类似，它继承自 Collection&lt;T&gt; 进而继承自 Iterable&lt;T&gt;。改变 list 的方法是由 MutableList&lt;T&gt; 加入的。这一模式同样适用于 Set&lt;out T&gt;/MutableSet&lt;T&gt; 及 Map&lt;K, out V&gt;/MutableMap&lt;K, V&gt;。详见下表 不可变 可变 Iterable MutableIterable Collection MutableCollection List MutableList Set MutableSet Map MutableMap List和Set的基本用法 123456789val numbers: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3)val readOnlyView: List&lt;Int&gt; = numbersprintln(numbers) // 输出 \"[1, 2, 3]\"numbers.add(4)println(readOnlyView) // 输出 \"[1, 2, 3, 4]\"readOnlyView.clear() // -&gt; 不能编译val strings = hashSetOf(\"a\", \"b\", \"c\", \"c\")assert(strings.size == 3) 总数操作符any 只要有一个元素符合判断条件，则返回true 123val list = listOf(1, 2, 3, 4, 5, 6)list.any &#123; it % 2 == 0&#125; // truelist.any &#123; it &gt; 10 &#125; // false all 只有全部的元素符合判断条件，则返回true 123val list = listOf(1, 2, 3, 4, 5, 6)list.all &#123; it &lt; 10 &#125; // truelist.all &#123; it % 2 == 0&#125; // false count 返回符合判断条件的元素总数 12val list = listOf(1, 2, 3, 4, 5, 6)list.count &#123; it % 2 == 0 &#125; // 3 fold 给定一个初始值，在初始值的基础上，通过给定的函数来累计所有元素。 123val list = listOf(1, 2, 3, 4, 5, 6)list.fold(4) &#123; total, next -&gt; total + next &#125; // 4+1+2+3+4+5+6 = 25list.fold(4) &#123; total, next -&gt; total * next &#125; // 4*1*2*3*4*5*6 = 2880 foldRight 与fold一样，只是顺序是从最后一项到第一项 12val list = listOf(1, 2, 3, 4, 5, 6)list.foldRight(4) &#123; total, next -&gt; total + next &#125; // 25 forEach 遍历的所有的元素，并执行给定的操作 12val list = listOf(1, 2, 3, 4, 5, 6)list.forEach &#123; println(it) &#125; forEachIndexed 与forEach类似，但是我们同时可以得到元素的index 12val list = listOf(1, 2, 3, 4, 5, 6)list.forEachIndexed &#123; (index, value) -&gt; println(\"position $index contains a $value\") &#125; max/min 返回最大/最小的一项，如果没有则返回null 123val list = listOf(1, 2, 3, 4, 5, 6)list.max() // 6list.min() // 1 maxBy/minBy 根据给定的函数返回最大/最小的一项，如果没有则返回null 123val list = listOf(1, 2, 3, 4, 5, 6)list.maxBy &#123; -it &#125; // 1list.minBy &#123; -it &#125; // 6 none 如果没有任何元素与给定的函数匹配，则返回true 12val list = listOf(1, 2, 3, 4, 5, 6)list.none &#123; it % 7 == 0 &#125; // true reduce 和fold一样，但是没有一个初始值。通过给定的函数来累计所有元素 12val list = listOf(1, 2, 3, 4, 5, 6)list.reduce &#123; total, next -&gt; total + next &#125; // 21 reduceRight 和reduce一样，但是顺序是从最后一项到第一项 12val list = listOf(1, 2, 3, 4, 5, 6)list.reduceRight &#123; total, next -&gt; total + next &#125; // 21 sum 返回所有元素的和 12val list = listOf(1, 2, 3, 4, 5, 6)list.sum() // 21 sumBy 返回所有元素通过给定的函数转换之后的数据总和 123val list = listOf(1, 2, 3, 4, 5, 6)list.sumBy &#123; it % 2 &#125; // 3list.sumBy &#123; it + 1 &#125; // 27 过滤操作符drop 返回包括去掉前n个元素的所有元素的列表 12val list = listOf(1, 2, 3, 4, 5, 6)list.drop(4) // listOf(5, 6) dropWhile 这个函数有点难理解，我们需要结合一下源码来看： 123456789101112public inline fun &lt;T&gt; Iterable&lt;T&gt;.dropWhile(predicate: (T) -&gt; Boolean): List&lt;T&gt; &#123; var yielding = false val list = ArrayList&lt;T&gt;() for (item in this) if (yielding) list.add(item) else if (!predicate(item)) &#123; list.add(item) yielding = true &#125; return list&#125; 调用dropWhile时，先遍历集合，如果集合中的元素不符合predicate函数的规则，则从当前元素开始，所有元素依次添加到新集合list并返回，如果集合中的元素都符合规则，则一个都不添加。我们以下面的例子来分析： 12val list1 = listOf(1, 2, 3, 4, 5, 6)list1.dropWhile &#123; it &lt; 3 &#125; // listOf(3, 4, 5, 6) 在上面的例子中，我们定义的函数规则是当前元素要小于3{it &lt; 3}，当集合遍历到3时，因为3是不小于3的，不符合函数的规则，所以从3开始，往后的元素都被添加到了新集合中。 再来看一个例子，我们把集合中的6放到最前面 12val list2 = listOf(6, 1, 2, 3, 4, 5)list2.dropWhile &#123; it &lt; 3&#125; // listOf(6, 1, 2, 3, 4, 5) 遍历集合时，因为第一个元素是6，不符合{it &lt; 3}，所要6及之后的元素都被添加到了新集合中 dropLastWhile 返回根据给定函数从最后一项开始去掉指定元素的列表 12val list = listOf(1, 2, 3, 4, 5, 6)list.dropLastWhile &#123; it &gt; 4 &#125; // listOf(1, 2, 3, 4) filter 返回符合给定条件的元素 123val list = listOf(1, 2, 3, 4, 5, 6)list.filter &#123; it % 2 == 0 &#125; // listOf(2, 4, 6)list.filter &#123; it &lt; 3 &#125; // listOf(1, 2) filterNot 返回所有不符合给定函数条件的元素 12val list = listOf(1, 2, 3, 4, 5, 6)list.filterNot &#123; it % 2 == 0&#125; // listOf(1, 3, 5) filterNotNull 返回集合中非null的函数 12val list = listOf(1, 2, 3, 4, 5, null)println(list.filterNotNull()) // listOf[1, 2, 3, 4, 5] slice 返回指定区域的元素 123val list = listOf(1, 2, 3, 4, 5, 6)list.slice(0..3) // listOf(1, 2, 3, 4)list.slice(listOf(1, 3, 4)) // listOf(2, 4, 5) (0..3)：表示取出第0个到第3个之间的元素 listOf(1, 3, 4)：表示取出下标为1、3、4的元素 take 返回从第一个开始的n个元素(返回前n个元素) 12val list = listOf(1, 2, 3, 4, 5, 6)list.take(2) // listOf[1, 2] takeLast 返回从最后一个开始的n个元素(返回后n个元素) 12val list = listOf(1, 2, 3, 4, 5, 6)list.take(2) // listOf[5, 6] takeWhile 返回从第一个开始符合给定函数条件的元素 12val list = listOf(1, 2, 3, 4, 5, 6)list.takeWhile &#123; it &lt; 3 &#125; // listOf[1, 2] 映射操作符flatMap 遍历所有的元素，为每个元素创建一个集合，最后把所有的集合放在一个集合中。 什么意思呢，就是你可以把每一个元素转化成一个新的list，最后这些list会合并成一个大的list。我们通过代码来分析： 12val list = listOf(1, 2, 3, 4, 5, 6)list.flatMap &#123; listOf('a' + it) &#125; // listOf(b, c, d, e, f, g) 上面的例子中，我们通过函数listOf(&#39;a&#39;+ it)把每一个元素都转换成了新的list。因为我们有6个元素，所以会生成6个list(listOf(b)、listOf(c)、listOf(d)、listOf(e)、listOf(f)和listOf(g))，最后会遍历这6个list，把这6个list中的每一项添加到一个新的list中。当然你也可以为listOf(&#39;a&#39; + it)添加多个元素，看下面的例子： 12val list = listOf(1, 2, 3, 4, 5, 6)list.flatMap &#123; listOf(it, 'a' + it) &#125; // listOf(1, b, 2, c, 3, d, 4, e, 5, f, 6, g) groupBy 返回一个根据给定函数分组后的map，把函数的返回值作为key，符合条件的所有元素作为value 123val list = listOf(1, 2, 3, 4, 5, 6)// 返回为 mapOf(\"odd\" to listOf(1, 3, 5), \"even\" to listOf(2, 4, 6)&#125;list.groupBy &#123; if (it % 2 ==0) \"even\" else \"odd\" &#125; map 返回一个每一个元素根据给定的函数转换所组成的List(把元素列表中的每一项进行相应计算或转成其它你想要的任何格式)。 把元素中的每一项乘2： 12val list = listOf(1, 2, 3, 4, 5, 6)list.map &#123; it * 2 &#125; // listOf(2, 4, 6, 8, 10, 12) 把元素中的每一项转成字母： 12val list = listOf(1, 2, 3, 4, 5, 6)list.map &#123; 'a' + it &#125; // listOf(b, c, d, e, f, g) mapIndexed 和map一样，但是我们可以同时得到元素的index 12val list = listOf(1, 2, 3, 4, 5, 6)list.mapIndexed &#123; index, it -&gt; index + it &#125; // listOf(1, 3, 5, 7, 9, 11) mapNotNull 和map一样，但是会过滤掉为null的元素 123456class Person(val name: String? = null)val list = listOf(Person(), Person(\"Alice\"))// maplist.map &#123; it.name &#125; // listOf(null, \"Alice\")// mapNotNulllist.mapNotNull &#123; it.name &#125; // listOf(\"Alice\") 元素操作符contains 如果的元素可以在集合中找到，则返回true 12val list = listOf(1, 2, 3, 4, 5, 6)list.contains(2) // true elementAt 返回给定index对应的元素，如果index数组越界则会抛出IndexOutOfBoundsException 12val list = listOf(1, 2, 3, 4, 5, 6)list.elementAt(1) // 2 elementAtOrElse 返回给定index对应的元素，如果index数组越界则会返回给定函数的返回值，函数中的参数为给定的index。如下图所示：it为传入的10 12val list = listOf(1, 2, 3, 4, 5, 6)list.elementAtOrElse(10, &#123; 2 * it &#125;) // 20 elementAtOrNull 返回给定index对应的元素，如果index数组越界则会返回null 12val list = listOf(1, 2, 3, 4, 5, 6)list.elementAtOrNull(10) // null first 返回符合给定函数条件的第一个元素，如果没有符合抛出java.util.NoSuchElementException 123val list = listOf(1, 2, 3, 4, 5, 6)list.first() // 1list.first &#123; it % 2 == 0 &#125; // 2 firstOrNull 返回符合给定函数条件的第一个元素，如果没有符合则返回null 123val list = listOf(1, 2, 3, 4, 5, 6)list.firstOrNull() // 1list.firstOrNull &#123; it % 7 == 0 &#125;) // null indexOf 返回指定元素的第一个index，如果不存在，则返回-1 12val list = listOf(1, 2, 3, 4, 5, 6)list.indexOf(4) // 3 indexOfFirst 返回第一个符合给定函数条件的元素的index，如果没有符合则返回-1 12val list = listOf(1, 2, 3, 4, 5, 6)list.indexOfFirst &#123; it % 2 == 0 &#125; // 1 indexOfLast 返回最后一个符合给定函数条件的元素的index，如果没有符合则返回-1 12val list = listOf(1, 2, 3, 4, 5, 6)list.indexOfLast &#123; it % 2 == 0 &#125; // 5 last 返回符合给定函数条件的最后一个元素 12val list = listOf(1, 2, 3, 4, 5, 6)list.last &#123; it % 2 == 0 &#125; // 6 lastIndexOf 返回的指定元素的最后一个index，如果不存在，则返回-1 123val list = listOf(1, 2, 3, 4, 5, 6)list.lastIndexOf(2) // 1list.lastIndexOf(7) // -1 single/singleOrNull 返回符合给定函数的单个元素，如果没有符合或者超过一个，single抛出异常，singleOrNull返回null 1234val list = listOf(1, 2, 3, 4, 5, 6)list.single &#123; it % 5 == 0 &#125; // 5list.single &#123; it % 2 == 0 &#125; // java.lang.IllegalArgumentExceptionlist.singleOrNull &#123; it % 2 == 0 &#125; // null 生产操作符partition 把一个集合通过给定的函数分为两个集合，符合条件的作为一个，不符合的作为另一个 12val list = listOf(1, 2, 3, 4, 5, 6)list.partition &#123; it % 2 == 0 &#125; // Pair(listOf(2, 4, 6), listOf(1, 3, 5)) plus 使用+号操作符把两个集合合并到一个集合中 12val list = listOf(1, 2, 3, 4, 5, 6)list + listOf(7, 8 ) // listOf(1, 2, 3, 4, 5, 6, 7, 8) zip(返回值 List&lt;Pair&gt;) 返回由Pair组成的List，每个Pair由两个集合中相同index的元素组成。这个返回的List的大小是由最小的那个集合决定 12val list = listOf(1, 2, 3, 4, 5, 6)list.zip(listOf(7, 8)) // listOf(Pair(1, 7), Pair(2, 8)) unzip 从包含Pair的List中生成包含List的Pair 。有点拗口，看代码 12val list = listOf(Pair(5, 7), Pair(6, 8))list.unzip() // Pair(listOf(5, 6), listOf(7, 8)) 看上面的代码，还是有点难理解，我们需要结合源码来看 12345678910public fun &lt;T, R&gt; Iterable&lt;Pair&lt;T, R&gt;&gt;.unzip(): Pair&lt;List&lt;T&gt;, List&lt;R&gt;&gt; &#123; val expectedSize = collectionSizeOrDefault(10) val listT = ArrayList&lt;T&gt;(expectedSize) val listR = ArrayList&lt;R&gt;(expectedSize) for (pair in this) &#123; listT.add(pair.first) listR.add(pair.second) &#125; return listT to listR&#125; unzip方法中，会定义两个集合，一个集合会添加list元素Pair(5,7), Pair(6,8)的first，出就是5、6，另一个集合会添加second，也就是7、8 顺序操作符reversed 返回一个倒序的list 12val list = listOf(1, 2, 3, 4, 5, 6)list.reversed() // listOf(6, 5, 4, 3, 2, 1) sorted 把list进行生序排列 12val list = listOf(1, 3, 2, 5, 4, 6)list.sorted() // listOf(1, 2, 3, 4, 5, 6) sortedBy 把不符合条件的元素按照在集合中之前的顺序放在集合的最前面，把符合条件的元素依次放在后面 12val list = listOf(7, 6, 3, 2, 5, 4, 1)list.sortedBy &#123; it &gt; 2 &#125; // listOf(2, 1, 7, 6, 3, 5, 4) 看代码，因为2,1不符合条件，所以把2,1按之前的顺序放到最前面，7,6,3,5,4仿照之前的顺序依次放到后面 sortedDescending 把list进行降序排列 12val list = listOf(7, 4, 3, 1, 5, 6, 2)list.sortedDescending() // listOf(7, 6, 5, 4, 3, 2, 1) sortedByDescending 和sortedBy类似，只不过是把符合条件的放在集合的前面，不符合的放在集合的后面 12val list = listOf(7, 4, 3, 1, 5, 6, 2)list.sortedByDescending &#123; it &gt; 3 &#125; // listOf(7, 4, 5, 6, 3, 1, 2) 参考: 《kotlin-for-android-developers》《kotlin in action》","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"yzbzz.github.io/tags/kotlin/"}]},{"title":"Kotlin扩展","date":"2018-03-13T03:36:48.000Z","path":"2018/03/13/android/kotlin-extensions/","text":"","tags":[]},{"title":"Kotlin注解","date":"2018-03-12T03:44:40.000Z","path":"2018/03/12/android/kotlin-annotations/","text":"前言关于注解可以参考以面文章： 秒懂，Java 注解 （Annotation）你可以这样学 注解声明注解是将元数据附加到代码的方法。 Java 1public @interface Fancy &#123;&#125; kotlin 1annotation class Fancy 注解类型 @Target：指定注解的作用域(类、函数、属性、表达式等) AnnotationTarget.CLASS：用作类 AnnotationTarget.FIELD：用作字段 AnnotationTarget.FUNCTION：用作方法 AnnotationTarget.PROPERTY：用作属性 @Retention：注解的存活时间(SOURCE、BINARY、RUNTIME) AnnotationRetention.BINARY：注解只被保留到编译进行的时候，它并不会被加载到 JVM 中 AnnotationRetention.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们 AnnotationRetention.SOURCE：注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视 @Repeatable：允许在单个元素上多次使用该注解 @MustBeDocumented：指定该注解是公有 API 的一部分，并且应该包含在生成的 API 文档中显示的类或方法的签名中。 12345@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)@Retention(AnnotationRetention.SOURCE)@MustBeDocumentedannotation class Fancy 用法12345@Fancy class Foo &#123; @Fancy fun baz(@Fancy foo: Int): Int &#123; return (@Fancy 1) &#125;&#125; 对类的主构造函数进行标解，这时的类不能省略constructor关键字 123class Foo @Inject constructor(dependency: MyDependency) &#123; // ……&#125; 对属性访问器进行注解 1234class Foo &#123; var x: MyDependency? = null @Inject set&#125; 构造函数注解的构造函数可以带参数 12annotation class Special(val why: String)@Special(\"example\") class Foo &#123;&#125; 允许的参数类型有： 对应Java的原生类型(Int、Long等等) 字符串 类(Foo::class) 枚举 其他注解 上面已列类型的数组 注解参数不可以为空类型，因为JVM不支持将null作为注解属性的值 如果注解用作另一个注解的参数，则其不能以@字符作为前缀 12345annotation class ReplaceWith(val expression: String)annotation class Deprecated( val message: String, val replaceWith: ReplaceWith = ReplaceWith(\"\"))@Deprecated(\"This function is deprecated, use === instead\", ReplaceWith(\"this === other\")) 如果需要将一个类作为注解的参数，请使用Kotlin的类。Kotlin 编译器会自动将其转换为 Java 类，以便 Java 代码能够正常看到该注解和参数 。 123import kotlin.reflect.KClassannotation class Ann(val arg1: KClass&lt;*&gt;, val arg2: KClass&lt;out Any&gt;)@Ann(String::class, Int::class) class MyClass Lambada注解也可以用于lambda。它们会应用于生成 lambda 表达式体的 invoke() 方法上 12annotation class Suspendableval f = @Suspendable &#123; Fiber.sleep(10) &#125;","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"yzbzz.github.io/tags/kotlin/"}]},{"title":"Kotlin反射","date":"2018-03-12T03:18:35.000Z","path":"2018/03/12/android/kotlin-reflection/","text":"反射在Java平台，使用反向功能需要单独的Jar包(kotlin-reflect.jar)。使用Android Studio开发Kotlin项目，会自动引入kotlin-reflect.jar 类引用最基本的反射功能是获取kotlin类的运行时引用 以下示例为Java、Kotlin的实现 Java 12Class&lt;?&gt; myClass = MyClass.class;Class&lt;?&gt; myClass = Class.forName(\"packageName.MyClass\") kotlin(如果调用的类是java类，需要添加.java后缀) 1234// 引用kotlin类val c = MyClass::class// 引用java类val c = MyClass::class.java 绑定的类引用我们可以使用::class语法获取对象的精确类的引用 1234open class Fruit()class Apple: Fruit()val fruit: Fruit = Apple()println(\"fruit type is $&#123;fruit::class.qualifiedName&#125;\") // fruit type is Apple 函数引用可以通过下面的方式获取到函数 1234567891011121314151617181920class Point(var x: Int, var y: Int) &#123; fun getPointX(): Int &#123; return x &#125; fun printPointY() &#123; println(y) &#125;&#125;// 第一种：可以使用::操作符获取函数val getX = Point::getPointXval getY = Point::printPointYval p = Point(1, 2)println(getX.invoke(p))getY.invoke(Point(3, 4))// 第二种：使用Java的反射方式val getX = Point::class.java.getMethod(\"getPointX\")print(getX.invoke(Point(2, 3))) 我们可以使用::操作符把一个函数作为值传递给另一个函数 123fun isOdd(x: Int) = x % 2 != 0val numbers = listOf(1, 2, 3)println(numbers.filter(::isOdd)) // 输出 [1, 3] 这里 ::isOdd 是函数类型 (Int) -&gt; Boolean 的一个值 ::也可以用于重载函数 12345fun isOdd(x: Int) = x % 2 != 0fun isOdd(s: String) = s == \"brillig\" || s == \"slithy\" || s == \"tove\"val numbers = listOf(1, 2, 3)println(numbers.filter(::isOdd)) // refers to isOdd(x: Int) 或者，你也可以赋值给变量 1val predicate: (String) -&gt; Boolean = ::isOdd // 引用到 isOdd(x: String) 如果我们需要使用一个类的成员，或者一个扩展函数，它需要是限定的。例如：String::toCharArray为String类提供的扩展函数:String.() -&gt; CharArray 函数组合考虑下面的函数 123fun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B): (A) -&gt; C &#123; return &#123; x -&gt; f(g(x)) &#125;&#125; 它返回传递给它的两个函数的组合：compose(f, g) = f(g(*))。现在你可以这样调用它 123456fun length(s: String) = s.lengthval oddLength = compose(::isOdd, ::length)val strings = listOf(\"a\", \"ab\", \"abc\")println(strings.filter(oddLength)) // Prints \"[a, abc]\" 属性引用我们可以使用::来访问属性 12345678910val x = 1var y = 1fun main(args: Array&lt;String&gt;) &#123; println(::x.get()) // prints \"1\" println(::x.name) // prints \"x\" ::y.set(2) println(y) // 输出 \"2\"&#125; 对于val，表达式::x返回KProperty&lt;Int&gt;类型的值，我们可以使用get()来取值，也可以直接使用name来取值。 对于var，表达式::y返回 KMutableProperty类型的值，提供get()/set()供我们调用 在没有参数的函数中，也可以使用属性引用： 12val strs = listOf(\"a\", \"bc\", \"def\")println(strs.map(String::length)) // prints [1, 2, 3] 访问类的成员属性 123456class A(val p: Int)fun main(args: Array&lt;String&gt;) &#123; val prop = A::p println(prop.get(A(1))) // prints \"1\"&#125; 对于扩展属性 123456val String.lastChar: Char get() = this[length - 1]fun main(args: Array&lt;String&gt;) &#123; println(String::lastChar.get(\"abc\")) // prints \"c\"&#125; 与Java反射的互操作性 例如，要查找一个用作 Kotlin 属性 getter 的 幕后字段或 Java方法，可以这样写 12345678import kotlin.reflect.jvm.* class A(val p: Int) fun main(args: Array&lt;String&gt;) &#123; println(A::p.javaGetter) // prints \"public final int A.getP()\" println(A::p.javaField) // prints \"private final int A.p\"&#125; 获取对应于Java的Kotlin类，使用.kotlin扩展属性 1fun getKClass(o: Any): KClass&lt;Any&gt; = o.javaClass.kotlin 构造函数引用可以使用::操作符来引用构造函数 1234567class Foofun function(factory: () -&gt; Foo) &#123; val x: Foo = factory()&#125;function(::Foo) 绑定函数和属性引用您可以引用特定对象的实例方法: 12345678val numberRegex = \"\\\\d+\".toRegex()println(numberRegex.matches(\"29\")) // prints \"true\" val isNumber = numberRegex::matchesprintln(isNumber(\"29\")) // prints \"true\"val strings = listOf(\"abc\", \"124\", \"a70\")println(strings.filter(numberRegex::matches)) // 输出“[124]” 你也可以进行赋值操作 12val isNumber: (CharSequence) -&gt; Boolean = numberRegex::matchesval matches: (Regex, CharSequence) -&gt; Boolean = Regex::matches 属性引用也可以被绑定: 12val prop = \"abc\"::lengthprintln(prop.get()) // prints \"3\" 无需显式指定 this 作为接收者：this::foo 与 ::foo 是等价的。","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"yzbzz.github.io/tags/kotlin/"}]},{"title":"flutter-started","date":"2018-03-09T08:56:03.000Z","path":"2018/03/09/flutter/flutter-started/","text":"参考：https://book.flutterchina.club/chapter1/flutter_intro.html 简介Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 它也是构建未来的Google Fuchsia应用的主要方式。 Flutter框架结构 Flutter Framework这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下： 底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个dart UI层，对应的是Flutter中的dart:ui包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。 Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。 Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而我们Flutter开发的大多数场景，只是和这两层打交道。 Flutter Engine这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 dart:ui库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。","tags":[{"name":"flutter","slug":"flutter","permalink":"yzbzz.github.io/tags/flutter/"}]},{"title":"Kotlin委托","date":"2018-03-09T03:15:35.000Z","path":"2018/03/09/android/kotlin-delegation/","text":"类委托创建一个类Derived，实例Base接口，并将其所有公共方法委托给指定的对象。 1234567891011121314interface Base &#123; fun print()&#125;class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;class Derived(b: Base) : Base by bfun main(args: Array&lt;String) &#123; val b = BaseImpl(10) Derived(b).print() // prints 10&#125; Derived超类列表中的by-子句表明，b将会在Derived对象的内部存储， 并且编译器将生成转发给 b 的所有 Base 的方法。 注意：override标注的方法会取代委托对象中的实现。如果你在Derived中添加了override fun print() { print(&quot;abc&quot;) }，程序会输入abc而不是10。 委托属性kotlin库提供了如下常见的属性类型 lazy properties(延迟属性): 该值只在首次访问时计算; observable properties(可观察属性): 监听器会收到该属性变化时的通知; 把属性存储在map中, 而不是每个属性都使用单独字段存储. 为了涵盖这些(或其他)情况，Kotlin支持委托的属性： 123class Foo &#123; var p: String by Delegate()&#125; 语法：val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;，使用by关键字来实现委托。 按照约定，Delegate类必须具有getValue和（setValue — 对于var属性)方法。编译器创建一个隐藏的辅助属性，并使用委托对象的实例进行实始化，初始属性p会委托给该实例。对应的get()、set()会调用实例的getValue()和setValue方法。它们可以是成员函数，也可以是扩展函数。为了让例子看起来更简洁，这里我们省略掉了参数： 下面是演化过程 12345678910111213141516171819202122232425class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return \"$thisRef, thank you for delegating '$&#123;property.name&#125;' to me!\" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println(\"$value has been assigned to '$&#123;property.name&#125;' in $thisRef.\") &#125;&#125;class Foo &#123; private val delegate = Delegate() val p: String set(value: String) = delegate.setValue(..., value) get() = delegate.getValue(...)&#125;==&gt;class Foo &#123; var p: String by Delegate()&#125;val foo = Foo()val oldValue = foo.pfoo.p = newValue 使用委托属性：惰性初始化和”by lazy()”我们有一个耗时的方法loadEmails，用来从数据库检索电子邮件，我们希望只有在首次访问时才加载，并且只加载一次，我们可以使用下面的方法： 123456789101112131415161718fun loadEmails(person: Person): List&lt;Email&gt; &#123; println(\"load emails for $&#123;person.name&#125;\") return listOf(/*...*/)&#125;class Person(val name: String) &#123; private var _emails: List&lt;Email&gt;? = null val emails: List&lt;Email&gt; get() &#123; if (_emails == null) &#123; _emails = loadEmails(this) &#125; return _emails &#125;&#125;val p = Person(\"Alice\")p.emails // Load emails for Alice --&gt; 第一次访问会加载邮件p.emails 这个代码有点啰唆，且这个实现不是线程安全的。Kotlin提代了更好的解决方案 123class Person(val name: String) &#123; val emails by lazy &#123; loadEmails(this) &#125;&#125; lazy函数返回一个对象，该对象具有一个名为getValue且签名正确的方法，因此可以把它与by关键字一起使用来创建一个委托属性。lazy的参数是一个lambda，可以调用它来初始化这个值。默认情况下，lazy函数是线程安全的，如里需要，可以设置其他选项来告诉它要使用哪个锁，或者完全避开同步，如果该类永远不会在多线程环境中使用 实例委托属性12345678910class Person(val name: String, age: Int, salary: Int): PropertyChangeAware() &#123; var age: Int by Delegates.observable(0) &#123; prop, old, new -&gt; println(\"$old -&gt; $new\") &#125; var name: String by Delegates.observable(\"&lt;no name&gt;\") &#123; prop, old, new -&gt; println(\"$old -&gt; $new\") &#125;&#125; 如果你想能够截获一个赋值并做一些条件判断，可以使用vetoable代替observable 123456class Person(val name: String, age: Int, salary: Int): PropertyChangeAware() &#123; var age: Int by Delegates.observable(0) &#123; prop, old, new -&gt; new &gt; old &#125;&#125; 把属性储存在Map中 123456789class Person(val map: Map&lt;String, Any?) &#123; val name: String by map val age: Int by map&#125;// 属性的名称自动用作map中的键val person = Person(mapOf(\"name\" to \"John Doe\", \"age\" to 25))person.nameperson.age 这也适用于var属性，只需把map换成mutableMap 1234class Person(val map: mutableMap&lt;String, Any?) &#123; var name: String by map var age: Int by map&#125;","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"yzbzz.github.io/tags/kotlin/"}]},{"title":"Kotlin区间","date":"2018-03-08T08:46:47.000Z","path":"2018/03/08/android/kotlin-ranges/","text":"区间rangeTo..操作符实际上调用的是rangeTo函数，一般与in和in联用 1start..end -&gt; start.rangeTo(end) 整型区间（IntRange、 LongRange、 CharRange）可以迭代。 编译器会无额外开销的将它们转换为类似 Java 的基于索引的 for-循环 in(闭区间)123// 1..5 范围是闭区间 [1,5]if (i in 1..5) ==&gt; if (i &gt;= 1 &amp;&amp; i &lt;=5)if (i !in 1..5) ==&gt; if (i &lt;= 1 &amp;&amp; i &gt;=5) downTo1234567// 正序for (i in 1..5) // 倒序for (i in 5..1) // 不支持这种写法，什么都不输出==&gt;for (i in 5 downTo 1) step1234// 正序for (i in 1..5 step 2) ==&gt; for (i = 1; i&lt;=5 ; i+=2)//倒序for (i in downTo 5 step 2) ==&gt; for (i = 5;i &gt;= 1;i-=2) until(左闭右开区间)123// 1 until 5 范围是闭区间 [1,5)for (i in 1 until 5) println(i)// 1234 reversed12val list = listOf(1, 2, 3)println(list.reversed()) // [3, 2, 1] last返回数列的 last 值可能与原始数列的 last 值不同，以便保持不变式 (last - first) % step == 0 成立 123(1..12 step 2).last == 11 // 值为 [1, 3, 5, 7, 9, 11] 的数列(1..12 step 3).last == 10 // 值为 [1, 4, 7, 10] 的数列(1..12 step 4).last == 9 // 值为 [1, 5, 9] 的数列","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"yzbzz.github.io/tags/kotlin/"}]},{"title":"RecyclerView添加快速滚动","date":"2018-03-06T03:10:28.000Z","path":"2018/03/06/android/android-ui-rv/","text":"RecyclerView快速滚动使用ListView实现快速滚动只需要添加一行代码就可以了 1listView.setFastScrollEnabled(true) 在RecyclerView中，之前官方并没有提供快速滚动的API。但是现在在Android Support Library 26，官方终于提供了。让我们开始吧。 首先你需要进行以下配置 版本要是26以上哦 123456dependencies &#123; .... compile 'com.android.support:design:26.0.1' compile 'com.android.support:recyclerview-v7:26.0.1' ....&#125; 1234567buildscript &#123; repositories &#123; google() &#125; ....&#125; 设置你的xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:context=\"com.shaishavgandhi.fastscrolling.MainActivity\" tools:showIn=\"@layout/activity_main\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:fastScrollEnabled=\"true\" app:fastScrollHorizontalThumbDrawable=\"@drawable/thumb_drawable\" app:fastScrollHorizontalTrackDrawable=\"@drawable/line_drawable\" app:fastScrollVerticalThumbDrawable=\"@drawable/thumb_drawable\" app:fastScrollVerticalTrackDrawable=\"@drawable/line_drawable\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.constraint.ConstraintLayout&gt; fastScrollEnabled：是否启用快速滚动 fastScrollHorizontalThumbDrawable：水平滚动块 fastScrollHorizontalTrackDrawable： 水平滚动背景 fastScrollVerticalThumbDrawable： 竖直滚动块 fastScrollVerticalTrackDrawable： 竖直滚动背景 line_drawable.xml 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_pressed=\"true\" android:drawable=\"@drawable/line\"/&gt; &lt;item android:drawable=\"@drawable/line\"/&gt;&lt;/selector&gt; line.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;solid android:color=\"@android:color/darker_gray\" /&gt; &lt;padding android:top=\"10dp\" android:left=\"10dp\" android:right=\"10dp\" android:bottom=\"10dp\"/&gt;&lt;/shape&gt; thumb_drawable.xml 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_pressed=\"true\" android:drawable=\"@drawable/thumb\"/&gt; &lt;item android:drawable=\"@drawable/thumb\"/&gt;&lt;/selector&gt; thumb.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;corners android:topLeftRadius=\"44dp\" android:topRightRadius=\"44dp\" android:bottomLeftRadius=\"44dp\" /&gt; &lt;padding android:paddingLeft=\"22dp\" android:paddingRight=\"22dp\" /&gt; &lt;solid android:color=\"@color/colorPrimaryDark\" /&gt;&lt;/shape&gt; 效果如下： 原文链接： Fast Scrolling with RecyclerView","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"使用Android Studio模板节省开发时间","date":"2018-03-05T09:42:53.000Z","path":"2018/03/05/android/android-studio-templates/","text":"前言使用模板能大大减少写重复代码的时间。Android Studio内置三种样式的模板 模板 适用范围 Live Templates 代码块 File and Code Templates 创建单个文件 Plugin Templates 整个工程 Plugin Templates比较复杂，本文主要讲解前二个：Live Templates、File and Code Templates Live Templates什么是Live Templates呢 Live Templates就是把一些常用的代码块封装成几个快捷的字母，比如abc，当我们输入abc时，会自动生成封装好的代码。 以Toast为例，平时我们会这样写 1Toast.makeText(context, \"\", Toast.LENGTH_SHORT).show(); 每当要显示Toast时，都要敲上面的代码，很麻烦。细心的同学会发现，当输入Toast时，会在提示栏显示一些快捷的操作 我们点击第二项，会自动生成下面的代码 1Toast.makeText(mContext, \"\", Toast.LENGTH_SHORT).show(); 第二项中的Toast就是AndroidStudio内置的Live Templates 以mac 为例，可以通过下面的方式进入到Live Templates Android Studio -&gt; Preferences -&gt; Editor -&gt; Live Templates 从图中，我们可以看到AndroidStudio已经内置了一些模板，点开Android栏，会看到一些常用的Live Templates，其中包含我们上面提到的Toast。 当然，我们也可以定义自己的Live Templates，下面我们来封装一个AlertDialog 点击右边的+号，选择Template Group…新建一个组，组名我们这里填写UI，完成后会在左侧列表显示我们刚刚新建的UI组，选中UI，再次点击右侧的+号，这里我们选择Live Templates Abbreviation栏填写你要设置的快捷字母，这里我们填写showDialog，Description填写一个描述，这里我们填显示AlertDialog。 Template Text栏填写你要封装的代码块 12345678910111213141516AlertDialog.Builder builder = new AlertDialog.Builder($context$);builder.setTitle(\"\");builder.setMessage(\"\");builder.setNegativeButton(\"\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125;&#125;);builder.setPositiveButton(\"\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125;&#125;);builder.create().show(); 下面蓝色的Define，点开选择Java，如下图： 点击完成，我们的Live Templates就生成好啦，我们来试试在代码中输入showDialog 点击提示栏的第一个，就会自动生成我们封装好的AlertDialog代码，是不是很方便呢^^ File and Code Templates我们点击File -&gt; New的时候，会在右侧显示一些快捷项，供我们快速的创建文件 有时候我们希望可以定义自己的Templates，用于快速生成相应文件，比如RecycleView的Adapter文件，很多都是差不多的格式。 以mac 为例，可以通过下面的方式进入到File and Code Templates Android Studio -&gt; Preferences -&gt; Editor -&gt;File and Code Templates File -&gt; New -&gt; Edit File Templates 选中Files标签页，点击+号，Name栏输入RVAdapter，下面的输入框输入以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != \"\")package $&#123;PACKAGE_NAME&#125;;#endimport android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import java.util.List;#parse(\"File Header.java\")public class $&#123;NAME&#125; extends RecyclerView.Adapter&lt;$&#123;VIEWHOLDER_CLASS&#125;&gt; &#123; private final Context context; private List&lt;$&#123;ITEM_CLASS&#125;&gt; items; public $&#123;NAME&#125;(List&lt;$&#123;ITEM_CLASS&#125;&gt; items, Context context) &#123; this.items = items; this.context = context; &#125; @Override public $&#123;VIEWHOLDER_CLASS&#125; onCreateViewHolder(ViewGroup parent, int viewType) &#123; View v = LayoutInflater.from(parent.getContext()) .inflate(R.layout.$&#123;LAYOUT_RES_ID&#125;, parent, false); return new $&#123;VIEWHOLDER_CLASS&#125;(v); &#125; @Override public void onBindViewHolder($&#123;VIEWHOLDER_CLASS&#125; holder, int position) &#123; $&#123;ITEM_CLASS&#125; item = items.get(position); //TODO Fill in your logic for binding the view. &#125; @Override public int getItemCount() &#123; if (items == null)&#123; return 0; &#125; return items.size(); &#125; public class $&#123;VIEWHOLDER_CLASS&#125; extends RecyclerView.ViewHolder &#123; public MyViewHolder(View itemView) &#123; super(itemView); &#125; &#125;&#125; 点击OK，我们的Templates就创建好。 接下来，我们点击File -&gt; New，就会出现我们创建好的File Templates项 点击它，会出现下面的对话框 File name：填写你要创建的Adapter名称，例：TestRvAdapter VIEWHOLDER CLASS：填写你要创建的ViewHolder，例：MyViewHolder ITEM CLASS：填写你数据的类型，例: String LAYOUT RES ID：填写你的布局文件名称，例：acitivity_main 填写完成，我们的文件就生成好啦 OK，大功造成 ，是不是会节约很多时间呢^^ 参考文章： How to create your own file template in Android Studio","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"Kotlin操作符重载","date":"2018-03-02T08:42:35.000Z","path":"2018/03/02/android/kotlin-operator/","text":"操作符重载一元操作符 表达式 对应函数 +a a.unaryPlus() -a a.unaryMinus() !a a.not() ++a, a++ a.inc() –a, a– a.dec() 示例： 123456data class Point(val x: Int, val y: Int)operator fun Point.unaryMinus() = Point(-x, -y)operator fun Point.inc() = Point(x + 1, y + 1)var p = Point(10, 20)println(-p) // Point(x=10, y=-20)println(++p) // Point(x=11, y=21) 二元操作符 表达式 对应函数 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b)、a.mod(b)(弃用) a..b a.rangeTo(b) 示例： 12345678data class Point(val x: Int, val y: Int) &#123; operator fun plus(other: Point): Point &#123; return Point(x + other.x, y + other.y) &#125;&#125;val p1 = Point(10, 20)val p2 = Point(30, 40)println(p1 + p2) // Point(x=40, y=60) 没有用于位运算的特殊运算符 shl — 带符号左移 shr — 带符号右移 ushr — 无符号右移 and — 按位与 or — 按位或 xor — 按位异或 inv — 按位取反 示例： 123456// kotlinval num = 1 shl 4println(num) // 16==&gt;// javaint num = 1 &lt;&lt; 4 in操作符 表达式 对应函数 a in b b.contains(a) a !in b !b.contains(a) 示例： 1234567data class Rectangle(val upperLeft: Point, val lowerRight: Point)operator fun Rectangle.contains(p: Point): Boolean &#123; return p.x in upperLeft.x until lowerRight.x &amp;&amp; p.y in upperLeft.y until lowerRight.y&#125;val rect = Rectangle(Point(10, 20), Point(50, 50))println(Point(20, 30) in rect) // true 下标访问操作符(通过下标来访问元素：get 和 set) 表达式 对应函数 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, …, i-n] a.get( i_1, …, i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, …, i_n] = b a.set(i_1, …, i_n, b) 示例： 12345678910111213141516171819202122232425// 一维operator fun Point.get(index: Int): Int &#123; return when(index) &#123; 0 -&gt; x 1 -&gt; y else -&gt; throw IndexOutOfBoundsException(\"Invalid coordinate $index\") &#125;&#125;val p = Point(10, 20)println(p[1]) // 20// 二维data class MutablePoint(var x: Int, var y: Int)operator fun MutablePoint.set(index: Int, value: Int) &#123; when(index) &#123; 0 -&gt; x = value 1 -&gt; y = value else -&gt; throw IndexOutOfBoundsException(\"Invalid coordinate $index\") &#125;&#125;val p = MutablePoint(10, 20)p[1] = 42println(p) // MutablePoint(x=10, y=42) 调用操作符(invoke) 表达式 对应函数 a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_i, …, i_n) a.invoke(i_1, …, i_n) 圆括号转换为调用带有适当数量参数的 invoke 示例： 12345678910class Greeter(val greeting: String) &#123; operator fun invoke(name: String) &#123; println(\"$greeting, $name!\") &#125;&#125;val bavarianGreeter = Greeter(\"Servus\") bavarianGreeter(\"Dmitry\") // Servus, Dmitry!==&gt;val bavarianGreeter = Greeter(\"Servus\")(\"Dmitry\") // Servus, Dmitry! 可以通过重写invoke实例工厂模式 123456789101112object Any &#123; operator fun invoke(name: String): String &#123; return name &#125; operator fun invoke(number: Int): Int &#123; return number &#125;&#125;val string = Any(\"Hello World!\");val int = Any(\"1\");println(\"$string, $int\") // Hello World! 1 复合赋值运算符 表达式 对应函数 a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.remAssign(b), a.modAssign(b) (弃用) 示例： 12345678operator fun &lt;T&gt; MutableCollection&lt;T&gt;.plusAssign(element: T) &#123; this.add(element)&#125;val list = arrayListOf(1, 2)list += 3val newList = list + listOf(4, 5)println(list) // [1, 2, 3]println(newList) // [1, 2, 3, 4, 5] 比较运算符(equals) 表达式 对应函数 a == b a?.equals(b) ?: (b === null) a != b !(a?.equals(b)) ?: (b ===null) (等式校验 == 被转换为equals函数的调用，以及null的校验) 注意：=== 和 !==（同一性检查）不可重载，因此不存在对他们的约定。 这个 == 操作符有些特殊：它被翻译成一个复杂的表达式，用于筛选 null 值。 null == null 总是 true，对于非空的 x，x == null 总是 false 而不会调用 x.equals()。 示例： 12345678910class Point(val x: Int, val y: Int) &#123; override fun equals(obj: Any?): Boolean &#123; if (obj === this) return true if (obj !is Point) return false return obj.x == x &amp;&amp; obj.y == y &#125;&#125;println(Point(10, 20) == Point(10, 20)) // trueprintln(Point(10, 20) != Point(5, 5)) // trueprintln(null == Point(1, 2)) // false 比较操作符(compareTo) 表达式 对应函数 a &gt; b a.compareTo(b) &gt; 0 a &lt; b a.compareTo(b) &lt; 0 a &gt;= b a.compareTo(b) &gt;= 0 a &lt;= b a.compareTo(b) &lt;= 0 所有的比较都转换为对 compareTo 的调用，这个函数需要返回 Int 值 示例： 12345678class Person(val firstName: String, val lastName: String): Comparable&lt;Person&gt; &#123; override fun compareTo(other: Person): Int &#123; return compareValuesBy(this, other, Person::lastName, Person::firstName) &#125;&#125;val p1 = Person(\"Alice\", \"Smith\")val p2 = Person(\"Bob\", \"Johnson\")println(p1 &lt; p2) // false 参考资料： Kotlin in Action Operator overloading","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"yzbzz.github.io/tags/kotlin/"}]},{"title":"Kotlin类与对象","date":"2018-03-02T03:12:56.000Z","path":"2018/03/02/android/kotlin-class/","text":"声明和初始化类类的定义123456class User constructor (_nickname: String) &#123; val nickname: String init &#123; nickname = _nickname &#125;&#125; \u0011和java不同，在java中，初始化代码是写在构造方法里面的，而kotlin是写在init方法里。 在上面的例子中，不需要把初始化代码放在初始化语句块中，因为它可以与nickname属性的声明结合。如果主构造方法没有注解或可见性修饰符，同样可以去掉constructor关键字。 123class User (_nickname: String) &#123; val nickname = _nickname&#125; 前两个例子在类体中使用val关键字声明了属性。如果属性用相应的构造方法参数来初始化，代码可以通过把val关键字加在参数前的方式来进行简化。 1class User (val _nickname: String) 我们也可以为构造方法参数声明一个默认值 1class User (val _nickname: String, val isSubscribed: Boolean = true) 如果所有的构造方法都有默认值，编译器会生成一个额外的不带参数的构造方法来使用所有的默认值。 如果你的类具有一个父类，主构造方法同样需要初始化父类。可以通过在基类列表的父类引用中提供父类构造方法参数的方式来做到这一点。 12open class User(val nickName: Stirng) &#123; ...... &#125;class TwitterUser(nickName: String): User(nickName) &#123; ...... &#125; 次构造函数123456789open class View &#123; constructor (ctx: Context) &#123;&#125; constructor (ctx: Context, attr: AttributeSet) &#123;&#125; constructor (ctx: context, attr: AttributeSet, defStyle: Int): this(ctx, attr) &#123;&#125;&#125;class MyButton: View &#123; constructor (ctx: Context): super(ctx) &#123;&#125; constructor(ctx: Context, attr: AttributeSet): super(ctx, attr) &#123;&#125;&#125; 类的实例要创建一个类的实例，只需要直接调用构造方法，不需要使用new关键字： 12val alice = User(\"Alice\")val bob = User(\"Bob\", false) 匿名对象使用object关键字创建匿名对象 1234button.setOnClickListener(object : View.OnClickListener &#123; override fun onClick(v: View?) &#123; &#125;&#125;) 创建单独的类(不继承，不实现接口) 12345val pair = object &#123; var first = 1 var second = \"a\"&#125;println(\"$&#123;pair.first&#125; $&#123;pair.second&#125;\") // 1 a 注意：匿名对象使用public修改符，那么匿名对象赋值的函数或属性的实际类型会是匿名对象声明的超类型，如果没声明超类型，会是Any。如下图，因为属性pair是用public，所以它的类型是Any，这样就访问不到里面的first和second 12345678910111213141516class Pair() &#123; private fun getPair() = object &#123; var first = 1 var second = \"a\" &#125; public val pair = object &#123; val first = 1 var second = \"a\" &#125; fun get() &#123; getPair().first // pair.first 这里会报错，因为属性pair是用public修饰的 &#125;&#125; 静态成员与方法kotlin没有static关键字，需要使用object来代替 java 12345678class User &#123; static String TAG = \"\"; static void getName() &#123;&#125; void getAge() &#123;&#125;&#125;// User.TAG// User.getName()// new User().getAge() kotlin 12345678910class User &#123; companion object &#123; val TAG = \"\" fun getName() &#123;&#125; &#125; fun getAge() &#123;&#125;&#125;// User.TAG// User.getName()// User().getAge() 使用companion object包裹的代码，都是静态的，java代码调用时，需要加companion关键字 12// javaUser.companion.TAG 还有一种，使用object 关键修饰类，这样类里的所有成员和方法都是静态的 1234567object User &#123; val TAG = \"\" fun getName() &#123;&#125;&#125;// User.TAG// User.getName()// User.getAge() 使用companion object实现单例模式123456789101112131415class SDKManager private constructor() &#123; private object SingletonHolder &#123; val instance = SDKManager() &#125; companion object &#123; val instance = SingletonHolder.instance // or fun get() = SingletonHolder.instance &#125;&#125;SDKManager.instanceSDKManager.get() 内部类和嵌套类：默认是嵌套类嵌套类不持有外部类的引用，而内部类持有 类A在别一个类B中声明 在Java中 在Kotlin中 嵌套类(不存储外部类的引用) static class A class A 内部类(存储外部类的引用) class A inner class A kotlin引用外部类实例 12345class Outer &#123; inner class Inner &#123; fun getOuterReference() = this@Outer &#125;&#125;","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"},{"name":"kotlin","slug":"kotlin","permalink":"yzbzz.github.io/tags/kotlin/"}]},{"title":"2018，遇见更好的自己","date":"2018-02-26T06:50:56.000Z","path":"2018/02/26/life/life-flag-2018/","text":"前言时间过的好快，转眼就到了而立之年。去年一年太颓废了，今年一定要重拾心情，做更好的自己。先定个小目标^^ 2018愿望清单1、精读5本编程书籍，编写20篇技术文章 ​ 已读书本：《kotlin in action》《kotlin-for-android-developers》 ​ 已完成15篇技术文章 2、练字，练完2本楷书字帖，2本行楷字帖 3、读完English in Use初级、中级、高级 4、每周花费2小时学习音乐，钢琴达到4级水平 5、每周花费2小时学习PS/AI/AE 6、学习IOS，能独立开发小APP 7、跑步100天 ​ 已跑15天 8、吃草1个月 ​ 已吃53天 9、200天左右，每天锻炼30分钟 ​ 20天 10、去电影院看2场电影 11、存款10W+ 12、学会Flutter","tags":[{"name":"life","slug":"life","permalink":"yzbzz.github.io/tags/life/"}]},{"title":"合适懒人的搬瓦工+ShadowsocksX教程","date":"2018-02-26T06:09:55.000Z","path":"2018/02/26/study/study-bwh-ssr/","text":"建议大家自行安装shadowsocks(可以配置单、多用户)，传送门：shadowsocks多用户配置，不喜欢折腾的，可以继续往下看 VPS服务器搭建通过之前一篇文章多图详解搬瓦工(Bandwagon)购买流程，我们已经完成了VPS的购买，接下来我们开始搭建自己的服务器 我们先回到首页，点击Client Area，Client Area会出现在下面2个地方 点击后进入到下面的界面 依次点击Services -&gt; My Services，进入到下面的界面 这里我们点击KiwiVM Control Panel进入到服务器控制面版。进入到服务器控制面版后，先把服务停掉(待会要重装系统)。 搬瓦工提供无限次重装系统，这里我们先把服务停掉，重装一下系统。停掉服务后，点击左侧的ShadowsocksR Server，进入到ShadowsocksR Server界面，查看一下支持的系统版本 从图中，我们可以看过，ShadowsocksR Server只支持Centos 6 (32 or 64 bit)的系统 ，所以我们需要重装一个Centos 6 (32 or 64 bit)的系统。 点击左边的Install new OS，选择centos-6-x86_64-bbr，进行重装系统 点击reload，进行重装系统 ，同时会进入下面的界面 这里的端口和服务器密码需要记下来，方便以后使用ssh连接服务器使用 如何进入服务器: 使用SSH客户端(Termius)连接服务器 稍等一会，刷新页面，点击左侧的Main controls，出现下面的界面，表示系统安装成功 接下来，我们要安装ShadowsocksX服务 ShadowsocksX服务安装点击左侧的ShadowsocksR Server 等待安装完成，出现下面界面，表示安装成功 点击Go back，进入详情页，拖到到页面到Step 2。不要关闭这个界面，后面会用到 至此，我们的ShadowsocksX服务安装完成，接下来，我们需要安装ShadowsocksX客户端 ShadowsocksX客户端安装这里以Mac OS系统为例，其它平台可以参考下面文章 Mac平台点击https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help 点击图中标示的链接，会进入到一个下载页，点击Download开始下载，下载完成后安装，安装成功后，打开ShadowsocksX，打开后，会在菜单出现一个纸飞机图标，点击它 因为我之前配过2个服务器，所以上面会显示2条记录。点击打开服务器设定 照着填就可以了，填完点击确定。大功告成，可以科学上网啦！(依然上不了的，可以把客户端软件关了，再重开) Windows平台点击https://github.com/shadowsocks/shadowsocks-windows/releases 其它平台地址：https://github.com/shadowsocks?page=1 自己慢慢找吧(^^)","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"CentOS7安装ownCloud","date":"2018-02-07T08:16:50.000Z","path":"2018/02/07/study/study-centos-owncloud/","text":"你可能会出现下面的错误： 1Failed to start httpd.service: Unit not found. 执行yum install httpd","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"android-gradle","date":"2018-02-07T02:20:42.000Z","path":"2018/02/07/hole/android-gradle/","text":"解决Kotlin和DataBinding冲突 Unresolved reference: databinding 在主工程的build.gradle文件添加下面一行 123dependencies &#123; kapt &quot;com.android.databinding:compiler:3.0.0&quot;&#125; Failed to open zip file 当我们编译项目时，有时会出现 1234Error:Failed to open zip file.Gradle&apos;s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)Re-download dependencies and sync project (requires network)Re-download dependencies and sync project (requires network) 这时我们可以去http://services.gradle.org/distributions/ 下载新的gradle，下载完成后不要解压 这里以gradle-4.5.1-all为例，找到.gradle的dists目录，这里以 macos为例： 1Finder -&gt; 前往文件夹 -&gt; 输入~/.gradle -&gt; wrapper -&gt; dists refreshing gradle project 有时间我们编译项目时，会卡在refreshing gradle project，参照上面，自行安装gradle-xxx-all的包 Error:All flavors must now belong to a named flavor dimension 在defaultConfig中加：flavorDimensions &#39;default&#39; 123456android &#123; defaultConfig &#123; multiDexEnabled = true flavorDimensions 'default' &#125;&#125; Unable to find a matching configuration 在buildTypes下的config加入matchingFallbacks 123456789101112buildTypes &#123; release &#123; //... &#125; debug &#123; //... &#125; innerTest &#123; //... matchingFallbacks = ['debug', 'release'] &#125;&#125; error style attribute not found @android:attr 去掉@符 123456789&lt;style name=\"PopupAnimation\" parent=\"@android:Animation\"&gt; &lt;item name=\"@android:windowEnterAnimation\"&gt;@anim/push_bottom_in&lt;/item&gt; &lt;item name=\"@android:windowExitAnimation\"&gt;@anim/push_bottom_out&lt;/item&gt;&lt;/style&gt;==&gt;&lt;style name=\"PopupAnimation\" parent=\"android:Animation\"&gt; &lt;item name=\"android:windowEnterAnimation\"&gt;@anim/push_bottom_in&lt;/item&gt; &lt;item name=\"android:windowExitAnimation\"&gt;@anim/push_bottom_out&lt;/item&gt;&lt;/style&gt; error:execution failed for task ‘:app:transformnativelibswithstripdebugsymbolfordebug’. 删除/sdk/ndk-bundle Vivo 手机使用 Android studio安装APK失败的解决办法在工程目录的gradle.properties中添加android.injected.testOnly = false即可 解决Android Studio在XML中使用自定义View输入自定义属性的时候没有任何提示的问题1我们在自定义View和自定义属性的时候，要保持自定义View的className和自定义属性的的declare-styleable名一样，根据这个约定，IDE才会自动提示 Received status code 400 from server: Bad Request出现此问题是因为给gradle配置了错误的代理。 macOS路径：/Users/userName/.gradle/gradle.properties 1234567891011121314151617## For more details on how to configure your build environment visit# http://www.gradle.org/docs/current/userguide/build_environment.html## Specifies the JVM arguments used for the daemon process.# The setting is particularly useful for tweaking memory settings.# Default value: -Xmx1024m -XX:MaxPermSize=256m# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8## When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects# org.gradle.parallel=true#Thu Sep 06 17:23:56 CST 2018systemProp.https.proxyPort=80systemProp.http.proxyHost=mirrors.neusoft.edu.cnsystemProp.https.proxyHost=mirrors.neusoft.edu.cnsystemProp.http.proxyPort=80 删除最后的四行","tags":[{"name":"hole","slug":"hole","permalink":"yzbzz.github.io/tags/hole/"}]},{"title":"记一次Android端H5调用微信支付引发的坑","date":"2018-01-30T07:28:26.000Z","path":"2018/01/30/hole/hole-android-js-wxpay/","text":"事件背景今天一位H5的同事过来找我们，说他们在H5里调用微信支付(不是通过jsapi调用)，到支付界面，点击返回键，会导致APP重新启动，把webview给关掉了 事件原因分析经过我一顿猛操作，最后发现原来是webview设置userAgent引发的问题。 因为H5的要求，我们会在userAgent里设置一些信息，这里以abc为例，我们把abc这个字符串设置到了userAgent里，同时在AndroidManifest的activity节点注册了abc的scheme 12// 设置userAgentwebSettings.setUserAgentString(ua + \" abc/\" + getVersionName()); 1234567// 设置scheme&lt;intent-filter&gt; &lt;data android:scheme=\"abc\" /&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;&lt;/intent-filter&gt; 这里设置之后，当点击微信支付的返回按钮后，发现微信会发起一个类似下面结构的Intent: 12url: abc://action: android.intent.action.VIEW 这里导致我们注册的scheme的Activiy会接收到，导致应用重启。 解决办法通过我们的观察，发现scheme是区别大小写的，我们最后把userAgent的abc改成大写ABC就OK了","tags":[{"name":"hole","slug":"hole","permalink":"yzbzz.github.io/tags/hole/"}]},{"title":"使用SSH客户端(Termius)连接服务器","date":"2018-01-30T06:20:34.000Z","path":"2018/01/30/study/study-centos-ssh/","text":"前言我们买的是远端服务器，没有用户界面的，只能通过命令行去操作我们的系统，那么如何进入我们的服务器呢 SSH连接服务器有二种方式： 第一种 点击搬瓦工的KiwiVM Control Panel，进入到服务器控制面板，点击左侧的Roo shell - basic进入服务器 第二种 如果嫌每次都要从浏览器进入比较麻烦，可以选择使用SSH连接我们的服务器 先下载ssh客户端：http://www.termius.com 下载完成后打开 界面上看到ssh user@hostname -p port这行字没，你可以直接使用下面的方式进行连接 1ssh root@170.1.2.3 -p 8388 hostname: 这里我写的是170.1.2.3，你需要填写你的服务器ip port: 同理，你需要填写你的服务器端口 点击connect后，会弹出框，要你输入服务器密码，输入正确后进入服务器 或者你可以点击右下角的+ New Host，输入你的配置信息，点击保存开始连接 Address：服务器的ip地址，类似这样: 170.1.2.3 Port: 服务器的端口，类似这样: 8388 Username: 这里填root Password：这里为你安装服务器时的密码，就是之前你使用搬瓦工重装系统后的服务器密码 如果你忘记了服务器密码怎么办，没有关系，从下面步骤重新获取 进入到搬瓦工服务器控制面板，先到Main controls点击stop停掉你的服务器，再点击左侧的Root password modification从新获取，获取完成后，别忘了到Main controls点击start打开你的服务器","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"Hexo错误集锦","date":"2018-01-30T02:38:13.000Z","path":"2018/01/30/hole/hexo-error/","text":"使用Hexo部署的过程中报出以下错误。 1Hexo: TypeError: Cannot set property 'lastIndex' of undefined 解决方法：打开主工程的配置文件_config.yml(非主题里面的配置文件)，找到auto_detect，设置为false即可 ERROR Deployer not found: git 1npm install hexo-deployer-git --save npm i hexo-generator-json-content –save","tags":[{"name":"hole","slug":"hole","permalink":"yzbzz.github.io/tags/hole/"}]},{"title":"使用CentOS7安装配置Jenkins","date":"2018-01-29T03:51:08.000Z","path":"2018/01/29/study/study-centos-jenkins/","text":"安装JavaJenkins依赖Java，如果你的系统没有安装的话，需要先安装Java，已安装的话，可以忽略。使用以下命令 安装Java 1yum install java 查看Java版本 1java -version 如果显示以下项，表示已安装 123openjdk version &quot;1.8.0_161&quot;OpenJDK Runtime Environment (build 1.8.0_161-b14)OpenJDK 64-Bit Server VM (build 25.161-b14, mixed mode) 如果你显示的是类似以下的界面 12java version \"1.5.0\" gij (GNU libgcj) version 4.3.3 你需要先删除Java，重新安装OpenJDK，因为CentOS的系统，如果java版本是GCJ的版本，会导致Jenkins不工作(https://issues.jenkins-ci.org/browse/JENKINS-743) 使用如下命令1、先删除旧的java 1yum remove java 2、查看OpenJDK版本 1yum search openjdk 显示如下界面 123456...java-1.8.0-openjdk.i686 : OpenJDK Runtime Environmentjava-1.8.0-openjdk.x86_64 : OpenJDK Runtime Environmentjava-1.8.0-openjdk-accessibility.i686 : OpenJDK accessibility connectorjava-1.8.0-openjdk-accessibility.x86_64 : OpenJDK accessibility connector... 3、安装OpenJDK 1yum install java-1.8.0-openJDK 安装Git如果你需要使用git，使用以下命令进行安装(-y表示所有安装时的确认项都选y) 1yum install -y git 安装Jenkins首先我们进入到Jenkins官网，传送门：https://jenkins.io/download/ 这时我们会看到两栏，左边的Long-term Support (LTS)是12周发布一版，右边的Weekly是每周发布一个版本。 这里我们以Weekly为例进行安装，拖动页面找到你自己的系统并点击 CentOS传送门：https://pkg.jenkins.io/redhat/ 在这个界面我们可以看到官网教我们安装的步骤，简单说明一下 第一步，输入以下命令拉取Jenkins库 12sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key 注意文章所说的2点 1.如果您之前从Jenkins中导入了密钥，那么“rpm—import”将会失败，因为您已经有了一个密钥。请忽略这一点，继续前进。 2.您需要显式地安装Java运行时环境，因为Oracle的Java rpm是不正确的，并且无法注册为提供Java依赖项。因此，在Java中添加显式的依赖项要求将强制安装OpenJDK JVM。(以述步骤已安装了java ，忽略此条) 你可能会出现以下现象 12[root@host ~]# sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.reposudo: wget: command not found 这里，你需要先安装wget 1yum install -y wget 安装Jenkins包 1yum install -y jenkins 更新Jenkins 1yum update jenkins 查看Jenkins端口 1cat /etc/sysconfig/jenkins | more 查找JENKINS_PORT，一般为&quot;8080&quot;，一屏显示不下的话，按回车查看，按control+c退出 1JENKINS_PORT=\"8080\" 开启Jenkins服务 1service jenkins start 浏览器访问: IP地址:8080 关闭Jenkins服务 1service jenkins stop 配置Jenkin首先使用浏览器打开Jenkin(ip:8080)，如果你是第一次安装，会出现以下界面 我们去图中的地址去查看密码 1cat /var/lib/jenkins/secrets/initialAdminPassword 选中密码，按command+c复制，然后command+v到浏览器管理员密码那一栏，点击继续，会出现 我们点击左边的安装推荐的插件，等待安装完成，完成后会出现 设置完你的管理员用户，点保存并完成进入下个界面，点准备就绪，进入下个界面 OK，Jenkins安装配置完成！ 更多操作传送门：https://wiki.jenkins.io/display/JENKINS/Installing+Jenkins+on+Red+Hat+distributions","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"shadowsocks多用户配置","date":"2018-01-26T07:55:52.000Z","path":"2018/01/26/study/study-bwh-ss/","text":"前言之前一篇文章，我们讲了合适懒人的搬瓦工+ShadowsocksX教程，我们使用的是搬瓦工自己的服务进行安装的，还没有看的同学请先看下。本篇主要讲解如何使用命令行的方式进行安装shadowsocks，配置单用户和多用户。 如何进入服务器: 使用SSH客户端(Termius)连接服务器 shadowsocks服务器配置这里我们安装的是python版本，首先进入官网:https://github.com/shadowsocks/shadowsocks/tree/master 进入后拖动页面，找到自己的服务器版本，我们这里以CentOS为例: 安装Git安装shadowsocks，需要先安装git CentOS 1yum install -y git Debian / Ubuntu 1apt-get install -y git 安装shadowsocksCentOS 12yum install python-setuptools &amp;&amp; easy_install pippip install git+https://github.com/shadowsocks/shadowsocks.git@master Debian / Ubuntu 12apt-get install python-pippip install git+https://github.com/shadowsocks/shadowsocks.git@master 安装完成后，打开 https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File 我们可以看到官网的一些描述，这里简单说明一下： 第一步，创建一个shadowsocks.json文件并打开，使用以下命令 1vi /etc/shadowsocks.json 第二步，按i键进入编辑模式，当按下i时，这时左下角会显示 INSERT字样，表示当前处于编辑模式。输入以下内容(因为是命令行模式，所以大家可以先使用文本编辑器，写好下面的文字，然后复制一下，贴到你的命令行) 单用户配置 12345678910&#123; \"server\":\"my_server_ip\", \"server_port\":8388, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"mypassword\", \"timeout\":300, \"method\":\"rc4-md5\", \"fast_open\": false&#125; my_server_ip填你的服务器地址 8388填你的端口(自定义的，可能不更改，保留8388) mypassword填写你要设置的密码 多用户配置 12345678910111213&#123; \"server\":\"my_server_ip\", \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"port_password\":&#123; \"端口1\":\"密码1\", \"端口2\":\"密码2\", \"端口3\":\"密码3\" &#125;, \"timeout\":600, \"method\":\"rc4-md5\", \"fast_open\": false&#125; my_server_ip填你的服务器地址 端口1、密码1填你要分配给客户端的端口和密码，比如’8388’:”123456”，后面的端口、密码同理 注意：method一栏，默认是aes-256-cfb，这里改为rc4-md5，这样上网会快一些，相应的客户端加密也要改成rc4-md5，别忘了 这里设置的项都是给你客户端连接时使用的 填好后，按ESC键退出编辑模式，输出:wq保存退出 第三步，开启或关闭服务 使用以下命令 开启服务 1ssserver -c /etc/shadowsocks.json -d start 关闭服务 1ssserver -c /etc/shadowsocks.json -d stop 开机自启动 1vi /etc/rc.local 在rc.local中添加 1sudo ssserver -c /etc/shadowsocks.json -d start 大功告成，愉快的玩耍吧(^^)","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"Linux","date":"2018-01-25T02:52:11.000Z","path":"2018/01/25/study/Centenos/","text":"linux上安装Docker","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"Linux","date":"2018-01-25T02:52:11.000Z","path":"2018/01/25/study/Linux/","text":"jenkins shadowsocks shadowscocks shadowscocks android sdk jenkins-github jenkins-github 拷贝文件scp scp不支持断点 使用scp拷贝远端文件到本地(使用id_rsa.pub) 1scp -i id_rsa.pub root@xx.xx.xx.xx:/var/opt/gitlab/backups/ /Users/userNmae/Work/backups rsync rsync支持断点 使用rsync(使用id_rsa.pub)拷贝远端文件到本地 1rsync -avzP -e \"ssh -i id_rsa.157\" root@xx.xx.xx.xx:/var/opt/gitlab/backups/ /Users/userNmae/Work/backups/ 1234567891011121314151617181920212223242526272829303132&gt; -v：显示rsync过程中详细信息。可以使用\"-vvvv\"获取更详细信息。&gt; -P：显示文件传输的进度信息。(实际上\"-P\"=\"--partial --progress\"，其中的\"--progress\"才是显示进度信息的)。&gt; -n --dry-run ：仅测试传输，而不实际传输。常和\"-vvvv\"配合使用来查看rsync是如何工作的。&gt; -a --archive ：归档模式，表示递归传输并保持文件属性。等同于\"-rtopgDl\"。&gt; -r --recursive：递归到目录中去。&gt; -t --times：保持mtime属性。强烈建议任何时候都加上\"-t\"，否则目标文件mtime会设置为系统时间，导致下次更新&gt; ：检查出mtime不同从而导致增量传输无效。&gt; -o --owner：保持owner属性(属主)。&gt; -g --group：保持group属性(属组)。&gt; -p --perms：保持perms属性(权限，不包括特殊权限)。&gt; -D ：是\"--device --specials\"选项的组合，即也拷贝设备文件和特殊文件。&gt; -l --links：如果文件是软链接文件，则拷贝软链接本身而非软链接所指向的对象。&gt; -z ：传输时进行压缩提高效率。&gt; -R --relative：使用相对路径。意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例。&gt; --size-only ：默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。&gt; -u --update ：仅在源mtime比目标已存在文件的mtime新时才拷贝。注意，该选项是接收端判断的，不会影响删除行为。&gt; -d --dirs ：以不递归的方式拷贝目录本身。默认递归时，如果源为\"dir1/file1\"，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1。&gt; --max-size ：限制rsync传输的最大文件大小。可以使用单位后缀，还可以是一个小数值(例如：\"--max-size=1.5m\")&gt; --min-size ：限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件。&gt; --exclude ：指定排除规则来排除不需要传输的文件。&gt; --delete ：以SRC为主，对DEST进行同步。多则删之，少则补之。注意\"--delete\"是在接收端执行的，所以它是在&gt; ：exclude/include规则生效之后才执行的。&gt; -b --backup ：对目标上已存在的文件做一个备份，备份的文件名后默认使用\"~\"做后缀。&gt; --backup-dir：指定备份文件的保存路径。不指定时默认和待备份文件保存在同一目录下。&gt; -e ：指定所要使用的远程shell程序，默认为ssh。&gt; --port ：连接daemon时使用的端口号，默认为873端口。&gt; --password-file：daemon模式时的密码文件，可以从中读取密码实现非交互式。注意，这不是远程shell认证的密码，而是rsync模块认证的密码。&gt; -W --whole-file：rsync将不再使用增量传输，而是全量传输。在网络带宽高于磁盘带宽时，该选项比增量传输更高效。&gt; --existing ：要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。&gt; --ignore-existing：要求只更新目标端不存在的文件。和\"--existing\"结合使用有特殊功能，见下文示例。&gt; --remove-source-files：要求删除源端已经成功传输的文件。&gt;","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"多图详解搬瓦工(Bandwagon)购买流程","date":"2018-01-25T02:52:11.000Z","path":"2018/01/25/study/study-bwh/","text":"（温馨提示：本文图片较多，请在WIFI情况下阅读） 前言在天朝，因为qian的原因，很多外网是访问不了的。身为程序员，很多时候是需要访问google进行问题搜索，这时候就需要fan qiang进行科学上网了。 可能有相当一部分人是买的VPN进行科学上网，但VPN一般比较贵，也不稳定，不如自己搭建VPS（相当于自己买一台海外服务器），一方面可以可以学习一下Linux，一方面还可以科学上网，还比VPN便宜不少。 VPS购买其实VPS搭建还是比较简单的，本文使用搬瓦工(Bandwagon)，搬瓦工对新手比较友好，而且官方支持ShadowsocksX，最重要的是支持支付宝，省去了很多麻烦，官网：https://bwh8.net 首先进入官网 点击VPS Hosting，进入到VPS Hosting页面，我们先选择最便宜的一款，购买完成后可以根据自身情况进行升降服务器，后续会介绍如何升降。KVM是新的架构，OVZ是老的架构，大家要选Order KVM，不要选错了。 大家不知道选哪个的话，可以网上搜一搜，推荐个地方： http://bwg.biaoniu.net/bwg/index-yhm.html 点击Order KVM，进入到详情页面，因为搬瓦工的VPS是经常变换的，可能你看到的页面和我的不太一样，不过没关系，下面我们会说到。 因为我选的这个VPS，只支持年付，所有Billing CyCle只有一个选项。你的VPS可能是下面的这种情况，我这里的截图是20G VPS的，因为10G VPS的只支持年付，没法截下面的图 注意： Monthly 表示月付，就是使用一个月 Quarterly 表示季付，就是使用三个月 Semi-Annually 表示半年 Annually 表示一年 建议大家选择一年，相对便宜，选完Billing Cycle，接下来选机房 这里我们选择洛杉矶机机房，上面的第二项(后续可以在控制面板切换)，选完之后点击下方的Add to Cart，进入到订单汇总页面 这里我们使用BWH26FXH3HIQ或BWH1ZBPVK这个优惠码(随时失效，大家可以百度搜一搜优惠码)，输入完优惠码后，点击右边的Validate Code&gt;&gt;，出现下面的界面，表示优惠码有效 确认没问题后，点击Checkout去结账 如果有账号的话，点击Click me to login进行登录。没有的话，填写下面的项，后面标了红色字体的尽量都填上，最好真实的，防止被误认为订单欺诈 重要提示：不要填中文，使用拼音代替。比如：姓名叫李白，LastName填li，FirstName填bai ，还有State/Region一栏，要先选择Country，这样State/Region才会变 输入完成之后，点击Update。 接下来选择支付方式，我们这里选择支付宝 点击Complete Order，会进入到支付宝支付界面 扫描完成支付(不要扫图中的码哦)，支付成功后会收到邮件通知，里面会有你的服务器ip地址等信息。 科学上网传送门：合适懒人的搬瓦工+ShadowsocksX教程 VPS服务器升降还记得文章上述的这个界面吗 点击Manage，进入到服务器管理页 点击后，进入下面的界面，大家可以按需选择","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"css-background","date":"2017-07-12T03:34:23.000Z","path":"2017/07/12/fe/css-background/","text":"本章包含以下内容 background-size background-origin 浏览器支持 IE 9 + Firefox 3.5 Chrome Safari Opera background-size YES YES YES YES YES background-origin YES YES YES YES YES Internet Explorer 9+、Firefox、Chrome、Safari 以及 Opera 支持新的背景属性。 CSS3 background-size 属性backgrond-size 属性规定背景图片的尺寸。您能够以像素或百分比规定尺寸。如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。 例1： 调整背景图片的大小： 123456div &#123; background:url(bg_flower.gif); -moz-background-size:63px 100px; /* 老版本的 Firefox */ background-size:63px 100px; background-repeat:no-repeat;&#125; 例2： 对背景图片进行拉伸，使其完成填充内容区域： 123456div &#123; background:url(bg_flower.gif); -moz-background-size:40% 100%; /* 老版本的 Firefox */ background-size:40% 100%; background-repeat:no-repeat;&#125; CSS3 background-origin 属性background-origin 属性规定背景图片的定位区域。 背景图片可以放置于 content-box、padding-box 或 border-box 区域。 实例 在 content-box中定位背景图片 1234567div &#123; background:url(bg_flower.gif); background-repeat:no-repeat; background-size:100% 100%; -webkit-background-origin:content-box; /* Safari */ background-origin:content-box;&#125; CSS3 多重背景图片CSS3 允许您为元素使用多个背景图像。 实例 为 body 元素设置两幅背景图片： 123body &#123; background-image:url(bg_flower.gif),url(bg_flower_2.gif);&#125; 新的背景属性 属性 描述 CSS background-clip 规定背景的绘制区域。 3 background-origin 规定背景图片的定位区域。 3 background-size 规定背景图片的尺寸。 3 background-clip 规定背景的绘制区域： 1234div &#123; background-color:yellow; background-clip:content-box;&#125; 语法 12// 默认border-boxbackground-clip: border-box|padding-box|content-box; 值 描述 border-box 背景被裁剪到边框盒 padding-box 背景被裁剪到内边距框。 content-box 背景被裁剪到内容框。","tags":[{"name":"fe","slug":"fe","permalink":"yzbzz.github.io/tags/fe/"}]},{"title":"css-border","date":"2017-07-11T09:28:04.000Z","path":"2017/07/11/fe/css-border/","text":"本章主要包含以下内容1边框&gt;内阴影&gt;背景图片&gt;背景颜色&gt;外阴影 border-radius box-shadow border-image 浏览器支持 IE 9 + Firefox 3.5 Chrome Safari Opera border-radius YES YES YES YES YES box-shadow YES YES YES YES YES border-image NO YES YES YES YES Internet Explorer 9+ 支持 border-radius 和 box-shadow 属性。 Firefox、Chrome 以及 Safari 支持所有新的边框属性。 注释：对于 border-image，Safari 5 以及更老的版本需要前缀 -webkit-。 Opera 支持 border-radius 和 box-shadow 属性，但是对于 border-image 需要前缀 -o-。 为了兼容各主流浏览器并支持这些主流浏览器的较低版本，在基于Webkit的Chrome和Safari等浏览器上使用box-shadow属性时，我们需要将属性的名称写成-webkit-box-shadow的形式。Firefox浏览器则需要写成-moz-box-shadow的形式。 123456789101112131415161718192021.box-radius &#123; //Firefox4.0- -moz-box-radius: 25px; //Safariand Google chrome10.0- -webkit-box-radius:25px; //Firefox4.0+、 Google chrome 10.0+ 、 Oprea10.5+ and IE9 box-radius: 25px; // 角度 border: 2px solid; // 边框&#125;.box-shadow &#123; //Firefox4.0- -moz-box-shadow:投影方式 X轴偏移量 Y轴偏移量阴影模糊半径 阴影扩展半径 阴影颜色; //Safariand Google chrome10.0- -webkit-box-shadow:投影方式 X轴偏移量 Y轴偏移量阴影模糊半径 阴影扩展半径 阴影颜色; //Firefox4.0+、 Google chrome 10.0+ 、 Oprea10.5+ and IE9 box-shadow: 投影方式 X轴偏移量 Y轴偏移量 阴影模糊半径 阴影扩展半径 阴影颜色; &#125; border-radius （用于为元素添加圆角边框!）定义和用法 border-radius 属性是一个简写属性，用于设置四个 border-*-radius 属性。 默认值 0 继承性 no 版本 CSS3 JavaScript语法： object.style.borderRadius=”5px” 语法 1border-radius: 1-4 length|% / 1-4 length|%; 注释：按此顺序设置每个 radii 的四个值。如果省略 bottom-left，则与 top-right 相同。如果省略 bottom-right，则与 top-left 相同。如果省略 top-right，则与 top-left 相同。 值 描述 length 定义圆角的形状 % 以百分比定义圆角的形状 例1： 1border-radius: 2em; 等价于 1234border-top-left-radius: 2em;border-top-right-radius: 2em;border-bottom-right-radius: 2em;border-bottom-left-radius: 2em; 例2 1border-radius: 2em 1em 4em / 0.5em 3em; 等价于： 1234border-top-left-radius: 2em 0.5em;border-top-right-radius: 1em 3em;border-bottom-right-radius: 4em 0.5em;border-bottom-left-radius: 1em 3em; box-shadow box-shadow: 投影方式 x轴偏移量 y轴偏移量 阴影模糊半径 阴影扩展半径 阴影颜色 阴影类型：此参数可选。如不设值，默认投影方式是外阴影；如取其唯一值“inset”，其投影为内阴影； X-offset:阴影水平偏移量，其值可以是正负值。如果值为正值，则阴影在对象的右边，其值为负值时，阴影在对象的左边 Y-offset:阴影垂直偏移量，其值也可以是正负值。如果为正值，阴影在对象的底部，其值为负值时，阴影在对象的顶部； 阴影模糊半径：此参数可选，，但其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊； 阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小； 阴影颜色：此参数可选。如不设定颜色，浏览器会取默认色，但各浏览器默认取色不一致，特别是在webkit内核下的safari和chrome浏览器下表现为透明色，在Firefox/Opera下表现为黑色（已验证），建议不要省略此参数。 border-image （属性允许您规定用于边框的图片！）123456789101112.box-image &#123; //Firefox4.0- -moz-box-image: url(border.png) 30 30 round; //Safariand Google chrome10.0- -webkit-box-image: url(border.png) 30 30 round; // Opera -o-border-image: url(border.png) 30 30 round box-image: url(border.png) 30 30 round; // 角度&#125;","tags":[{"name":"fe","slug":"fe","permalink":"yzbzz.github.io/tags/fe/"}]},{"title":"jenkins-android","date":"2017-07-07T03:37:13.000Z","path":"2017/07/07/hole/jenkins-android/","text":"之前用jenkins打包时，提示Failed to find Build Tools revision xx.x.x ，于是进入到var/lib/jenkins/tools/android-sdk/tools/下面，输入下面命令 1android list sdk -a 控制台没有反应，于是又试了下其他命令 1android -h 也没反应，瞬间懵逼。于是想看看其它命令是不是也没反应，切换到platform-tools目录去执行 adb 命令： 出现”libc.so.6: version ‘GLIBC_2.15’ not found”问题，才知道是由于glibc版本过低，升级glibc即可。 参照：http://blog.csdn.net/hnhuangyiyang/article/details/50392997 1.查看系统glibc支持的版本 1234strings /lib64/libc.so.6 |grep GLIBC #查看当前glibc版本 ll /lib64/libc.so.6 lrwxrwxrwx. 1 root root 12 Oct 9 2014 /lib64/libc.so.6 -&gt; libc-2.12.so 2.下载glibc源码包 (http://ftp.gnu.org/gnu/glibc/) 123cd /usr/src/ wget http://mirror.bjtu.edu.cn/gnu/glibc/glibc-2.15.tar.gz wget http://mirror.bjtu.edu.cn/gnu/glibc/glibc-ports-2.15.tar.gz #glibc插件 3.解压安装升级glibc 12345678tar zxvf glibc-2.15.tar.gz tar zxvf glibc-ports-2.15.tar.gz mv glibc-ports-2.15 glibc-2.15/ports mkdir build cd build ../glibc-2.15/configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin make -j4 make install 4.验证(查看系统glibc支持的版本) 1strings /lib64/libc.so.6 |grep GLIBC 5.误删libc.so.6解决办法(命令行执行如下：) 1#LD_PRELOAD=/lib/libc-2.12.so ln -s /lib/libc-2.12.so lib/libc.so.6 升级完glibc之后，android 命令终于有反应了，继续执行 1android list sdk -a 卡住了，想了想应该是被墙的原因，还好androd命令提供了代理参数： 12--proxy-host //设置代理host--proxy-port //设置代理端口 网络找了找个国内的Android代理镜像服务器 1http://mirrors.neusoft.edu.cn 端口：80 接下来执行 1android list sdk --proxy-host mirrors.neusoft.edu.cn --proxy-port 80 -s --all 成功了 123456789101112Packages available for installation or update: 184 1- Android SDK Tools, revision 25.2.5 2- Android SDK Platform-tools, revision 26 3- Android SDK Build-tools, revision 26 4- Android SDK Build-tools, revision 25.0.3 5- Android SDK Build-tools, revision 25.0.2 6- Android SDK Build-tools, revision 25.0.1 7- Android SDK Build-tools, revision 25 8- Android SDK Build-tools, revision 24.0.3 9- Android SDK Build-tools, revision 24.0.2 10- Android SDK Build-tools, revision 24.0.1 11- Android SDK Build-tools, revision 24 接下来执行下载sdk命令 12// --filter 3后面的数字3对面上面列表的项，这时表示下载 (3- Android SDK Build-tools, revision 26)android update sdk --no-ui --filter 3 --proxy-host mirrors.neusoft.edu.cn --proxy-port 80 -s --all 安装的时候会提示是否接受license 类似 1Do you accept the license &apos;android-sdk-license-c81a61d9&apos; [y/n]: 输入y之后开始下载，等待安装成功，又可以愉快的玩耍了","tags":[{"name":"hole","slug":"hole","permalink":"yzbzz.github.io/tags/hole/"}]},{"title":"git.md","date":"2017-05-09T02:47:43.000Z","path":"2017/05/09/git-md/","text":"git命令Git库迁移，从一个库迁移到另一个库 1234git clone --mirror &lt;URL to my OLD repo location&gt;cd &lt;New directory where your OLD repo was cloned&gt;git remote set-url origin &lt;URL to my NEW repo location&gt;git push -f origin 添加子仓库 1234git submodule add projectB.git projectBgit add .git commit -m &quot;add module&quot;git push 查看分支 123456// 查看本地所有分支git branch// 查看远程所有分支git branch -r// 查看所有本地分支和远程分支git branch -a 创建/切换分支 123456// 如果存在dev分支，则切换到该分支，否则新建分支git checkout dev// 创建本地dev1分支,然后切换到dev1分支git checkout -b dev1 =&gt; git branch dev1 git checkout dev1// 从远程分支dev创建本地分支dev1git checkout -b dev1 origin/dev 合并分支 12345// 合并dev1分支，这种模式下，删除分支后，会丢掉分支信息，可以用 --no-ff方法git merge dev1git merge --no-ff -m \"merge with no-ff\" dev1// 如果分支很多，这个分支历史可能就会变得很复杂了，可以使用 rebase，提交的历史会保持线性git rebase dev1分支 删除分支 123456789// 删除分支，如果没有完成合并会有提示git branch -d dev1// 强删除git branch -D dev1 // 删除远程分支git push origin --delete devorgit push origin :dev 提交分支 1234// 这里冒号可以提交到指定分支，上面命令，把提交本地 master 分支到远程的 dev 分支，远程没有dev这个分支，会创建。git push origin master:dev// 本地master提交到远程主分支mastergit push origin master =&gt; git push origin master:master 跟踪远程分支 从远程分支 checkout 出来的本地分支，称为 跟踪分支 (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git pull/push，Git 会自行推断应该向哪个服务器的哪个分支更新/推送数据。 123456// 建立追踪关系git branch -u origin/dev masterorgit branch --set-upstream-to origin/dev master// 查看所有分支跟踪关系git branch -vv 打Tag 1234// 打taggit tag -a v1.0 -m 'msg'// 推送taggit push origin v1.0 git push origin 推送分支 git rebase 合并分支 git tag -a -m ‘msg’ 打tag git push orign 推送tag git branch –set-upstream-to=origin/4.6.0 4.6.0 关连分支","tags":[]},{"title":"android-vr-ar-mr","date":"2017-05-03T09:23:57.000Z","path":"2017/05/03/android/android-vr/","text":"AR http://www.easyar.cn/view/sdk.html https://www.hiscene.com https://developer.vuforia.com https://developers.google.com/tango/downloads https://github.com/googlesamples/tango-examples-c Blog: http://www.jianshu.com/p/49d76c24ae46 http://blog.csdn.net/jaikydota163/article/details/52626788 http://www.cnblogs.com/yidan621/p/5677544.html http://blog.csdn.net/d276031034/article/details/54846434 http://blog.csdn.net/yywan1314520/article/details/51530537","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"life","date":"2017-05-03T09:23:57.000Z","path":"2017/05/03/life/life/","text":"blog 叠衣 Arc’teryx 始祖鸟(也有写作Arcteryx或鸟家) 作为来自加拿大的顶级户外装备，Arc’teryx 始祖鸟的背包，软壳，硬壳，冲锋衣裤不断的出现在各种媒体中（像近期的电影《谍影重重》）Arc’teryx 始祖鸟对户外运动全能极致的设计理念深受驴友们的认可，Arc’teryx 始祖鸟迷都知道Arc’teryx在 款式命名上，会将其等级和用途的缩写加在款式型号上作为区分，以便选购时能能过型号分辨其功能或定位上的差异，一般常见有AR、SV、LT、SL、MX、SK、RT、M、LS、SS等型号. ARCTERYX(始祖鸟)服装大体来说等级和用途与价格有很大的关系，但作为ARCTERYX(始祖鸟)户外玩家真正的关心的还在于使用环境上。让淘淘带大家看看Arc’teryx 始祖鸟官方是怎么定位和区别服装等级与用途. SV – Severe Use 向导级别: 针对最恶劣的极限环境所设计，采用了最耐用的材质，为了应付恶劣的天气都会加上风帽设计给予最完整的保护。适合三极探险（南北极和最高峰），可长时间的为使用者提供了最全天候的保护,但是所带来的是重量增加，因此除非你要去那些地方真的够冷，够险，够偏。否则一般探险使用大可不用买到此等级,当然有钱烧装备除外。 AR – All-Round Use 多功能级别：强调了一系列功能,使用中等厚度材质，能应付未来大多数环境的使用，以最完全的包覆剪裁设计。使用耐用的材质，虽然稍重了一些，但所带来的性价比是很高的，非常耐用能百分百应付国内所有的地形与气候，例如：Beta AR Jacket 与 Gamma AR Jacket。此型号若出现在底层排汗衣或中层保暖衣，则是(相对地)定位较适合秋冬使用，例如：Rho AR Zip Top 与 Delta AR Zip Top 系列。 MX – Mixed Use混合天气用途级别：针对不断变化的天气条件和多样的活动与多变地形环境使用，会尽可能地使用耐磨、透气、排汗、高活动性的布料。此定位的设计常只出现在 Soft Shell 类的衣物，如果活动区域的四季分明与海拔变化度大，通常很适合这类的衣物。 LT – Light 轻量化级别：使用轻量化材质，设计上追求简单，减少不必要的部份。以风雨衣来说大部分是降低材料的耐磨性来达到轻量；以保暖衣或排汗衣来说会使用较薄的布料，来达到适合三季的使用。 SL – Super Light 超轻量化级别：使用最轻量的布料，同时耐用性能有所降低。在风雨衣上很明显最具优势就属于 Gore-tex 的 Paclite 了，其他款式也会使用最轻量化的材质。超轻量化设计来说，目前来说风雨衣一定使用 Paclite了，底层衣会以利用布料的四向弹性来降低太多的剪裁，例如：Rho SL Crew。另外会降低一些细节上的设计，或用不同的思惟来设计，就像 Alpha SL Pullover 是一个明显的例子。 SK – Ski Specialized 滑雪专用：结合滑雪与雪地攀登的冬季设计。大方的衔接，额外的空间层次感，再加上较大的裤腿开放，以适应在雪上运动. LS（Long Sleeve）是长袖，SS（Short Sleeve）是短袖，RT (Rolltop) 卷口防水,M(Mountain )登山用途. 按照始祖鸟的官方分法，产品线是traverse（徒步）、endorphin（越野跑）、whiteline（滑雪）、essential（基础）、ascent（攀登）、24（城市休闲）、veilance（商务休闲）。 https://post.smzdm.com/p/595891/","tags":[{"name":"life","slug":"life","permalink":"yzbzz.github.io/tags/life/"}]},{"title":"refactor-demo","date":"2017-03-21T03:56:09.000Z","path":"2017/03/21/refactor/refactor-demo/","text":"重新组织函数Extract Method (提炼函数)(将这段代码放进一个独立函数中，并让函数名称解释该函数的用途)1234567891011121314151617void printOwing(double amount) &#123; printBanner(); // print details System.out.println(\"name: \" + _name); System.out.println(\"amout: \" + amount);&#125;==&gt;void printOwing(double amount) &#123; printBanner(); printDetails(amount);&#125;void printDetails(double amount) &#123; System.out.println(\"name: \" + _name); System.out.println(\"amout: \" + amount);&#125; Inline Method (内联函数)（在函数调用点插入函数体，然后移除该函数） 12345678910int getRating() &#123; return (moreThanFiveLateDeliveries()) ? 2 : 1;&#125;boolean moreThanFiveLateDeliveries() &#123; return _numberOfLateDeliveries &gt; 5;&#125;==&gt;int getRating() &#123; return (_numberOfLateDeliveries &gt; 5) ? 2 : 1;&#125; Inline Temp (内联临时变量)（将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。） 1234double basePrice = anOrder.basePrice();return (basePrice &gt; 1000);==&gt;return (anOrder.basePrice() &gt; 1000); Replace Temp with Query（以查询取代临时变量）(将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。) 123456789101112131415double basePrice = _quantity * _itemPrice;if (basePrice &gt; 1000) &#123; return basePrice * 0.95;&#125; else &#123; return basePrice * 0.98;&#125;==&gt;if (basePrice() &gt; 1000) &#123; return basePrice() * 0.95;&#125; else &#123; return basePrice * 0.98;&#125;double basePrice() &#123; return _quantity * _itemPrice;&#125; Introduce Explaining Variable（引用解释性变量）(将该复杂表达或其中一部分的结果放进一个临时变量，以此变量名称来解释表达式的用途。) 1234567891011121314if ((platform.toUpperCase().indexOf(\"MAC\") &gt; -1) &amp;&amp; (browser.toUpperCase().indexOf(\"IE\") &gt; -1) &amp;&amp; wasInitialized() &amp;&amp; resize &gt; 0 &#123; // do something&#125;==&gt;final boolean isMacOs = platform.toUpperCase().indexOf(\"MAC\") &gt; -1;final boolean isIEBrowser = browser.toUpperCase().indexOf(\"IE\") &gt; -1;final boolean wasResized = resize &gt; 0;if (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123; // do something&#125; Split Temporary Variable（分解临时变量）（针对每次赋值，创造一个独立、对应的临时变量） 123456789double temp = 2 * (_height + _width);System.out.println(temp);temp = _height * _width;System.out.println(temp);==&gt;final double perimeter = 2 * (_height + _width);System.out.println(perimeter);final double area = _height * _width;System.out.println(area); Remove Assignments to Parameters(以一个临时变量取代该参数的位置) 123456789101112int discount(int inputVal, int quantity, int yearToDate) &#123; if (inputVal &gt; 50) &#123; inputVal -= 2; &#125;&#125;==&gt;int discount(int inputVal, int quantity, int yearToDate) &#123; int result = inputVal; if (inputVal &gt; 50) &#123; result -= 2; &#125;&#125; Replace Method with Method Object(以函数对象取代函数)(将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数) 12345678910111213141516171819202122class Order &#123; double price() &#123; double primaryBasePrice double secondaryBasePrice .... return primaryBasePrice + secondaryBasePrice + ... &#125;&#125;==&gt;class Order &#123; double price() &#123; return new PriceCalculator(this).compute(); &#125;&#125;class PriceCalculator &#123; double primaryBasePrice double secondaryBasePrice ... double compute() &#123; return primaryBasePrice + secondaryBasePrice + ... &#125;&#125; Substitute Algorithm（替换算法）（将函数本体替换为另一个算法） 12345678910111213141516171819String foundPerson(String[] people) &#123; for (int i = 0; i &lt; people.length;i++) &#123; if (people[i].equals(\"Don\")) &#123; return \"Don\"; &#125; ... &#125; return \"\";&#125;==&gt;String foundPerson(String[] people) &#123; List candidates = Arrays.asList(new String[] &#123;\"Don\",\"John\",\"Kent\"&#125;); for (int i = 0; i &lt; people.length;i++) &#123; if (candidates.contains(people[i])) &#123; return people[i]; &#125; &#125; return \"\";&#125; 在对象之间搬移特性Move Method （搬移函数）“搬移函数”是重构理论的支柱。如是一个类有太多行为，或如果一个类与另一个类有太多合作而形成高度耦合，我就会搬移函数。通过这种手段，可以使系统中的类更简单，这些类最终也将更干净利落地实现系统交付的任务。 Move File (搬移字段)在类之间移动状态和行为，是重构过程中必不可少的措施。随着系统的发展，你会发现自己需要新的类，并需要将现有的工作责任拖到新的类中。在这个星期看似合理而正确的设计决策，到了下个星期可能不再正确。这没问题。如果你从来没遇到这种情况，那才有问题。 Extract Class（提炼类）（建立一个新类，将相关的字段和函数从旧类搬移到新类） 12345678910111213class Person &#123; String name, officeAreaCode, officeNumber; void getTelephoneNumber()&#123;&#125;&#125;==&gt;class Person &#123; String name; void getTelephoneNumber()&#123;&#125;&#125;class TelephoneNumber &#123; String areaCode, number; void getTelephoneNumber()&#123;&#125;&#125; Inline Class（将类内联化）将这个类的所有特性搬移到别一个类中，然后移除原类。 Hide Delegate（隐藏”委托关系”）在服务类上建立客户所需的所有函数，用以隐藏委托关系。 Remove Middle Man（移除中间人）让客户直接调用受托类 Introduce Foreign Method（引入外加函数）（在客户类中建立一个函数，并以第一参数形式传入一个服务类实例） 123456Date newStart = new Date(previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + 1);==&gt;Date newStart = nextDay(previousEnd);private static Date nextDay(Date arg) &#123; return new Date(previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate());&#125; Introduce Local Extension（引入本地扩展）建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。 重新组织数据Self Encapsulate Field（自封装字段）（为这个字段建立取值/设值函数，并且只以这些函数来访问字段） 1234567891011private int _low, _hight;boolean includes (int arg) &#123; return arg &gt;= _low &amp;&amp; arg &lt;= _high;&#125;==&gt;private int _low, _hight;boolean includes (int arg) &#123; return arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();&#125;int getLow() &#123;return _low;&#125;int getHight() &#123;return _hight;&#125; Replace Data Value with Object（以对象取代数据值）你有一个数据，需要与其他数据和行为一起使用才有意义。 Change Value to Reference（将值对象改为引用对象）你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。将这个值对象变世引用对象 Change Reference to Value （将引用对象改为值对象）你有一个引用对象，很小且不可变，而且不易管理。将它变成一个值对象。 Replace Array with Object（以对象取代数组）你有一个数组，其中的元素各自代表不同的东西。 (以对象替换数组，对于数组中的每个元素，以一个字段来表示) 1234567String[] row = new String[3];row[0] = \"Liverpool\";row[1] = \"15\";==&gt;Performance row = new Performance();row.setName(\"Liverpool\");row.setWins(\"15\"); Duplicate Observed Data（复制”被监视数据”）你有一些领域数据置身于GUI控件中，而领域函数需要访问这些数据。（将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据） Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）两个类都需要使用对方特性，但其间只有一条单向连接。（添加一个返回指针，并使修改函数能够同时更新两条连接） Change Bidirectional Association to Unidirectional （将双向关联改为单向关联） 两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。（去除不必要的关联） Replace Magic Number with Symbolic Constant（以字面常量取代魔法数） （创建一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。） 12345678double potentialEnergy(double mass, double height) &#123; return mass * 9.81 * height;&#125;==&gt;double potentialEnergy(double mass, double height) &#123; return mass * GRAVITATIONAL_CONSTANT * height;&#125;static final double GRAVITATIONAL_CONSTANT = 9.81; Encapsulate Field（封装字段 ） 你的类中存在一个public字段。将它声明为private，并提供相应的访问函数。 12345public String _name;==&gt;private String _name;public String getName() &#123;return _name;&#125;public void setName(String arg) &#123;_name = arg;&#125; Encapsulate Collection（封装集合）有个函数返回一个集合。（让这个函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数。） Replace Recore with Data Class（以数据类取代记录）你需要面对传统编程环境中的记录结构。为该记录创建一个”哑”数据对象。 Replace Type Code with Class（以类取代类型码）类之中有一个数值类型码，但它并不影响类的行为。（以一个新的类替换该数值类型码。） 123456789class Person &#123; int O, A, B, AB; int bloodGroup;&#125;==&gt;class Person &#123;&#125;class BloodGroup &#123; BloodGroup O, A, B, AB&#125; Replace Type Code with Subclasses（以子类取代类型码）你有一个不可变的类型码，它会影响类的行为： 12345678class Employee &#123; int ENGINEER; int SALESMAN;&#125;==&gt;class Employee &#123;&#125;class Engineer &#123;&#125;class Salesman &#123;&#125; Replace Type Code with State/Strategy（以State/Strategy取代类型码）你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。（以状态对象取代类型码） Replace Subclass with Fields（以字段取代子类）你的各个子类的唯一差别只在”返回常量数据”的函数身上。修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类 简化条件表达式Decompose Conditional（分解条件表达式）（从if、then、else三个段落中分别提炼出独立函数） 1234567891011if (date.before (SUMMER_START) || date.after(SUMMER_END)) &#123; charge = quantity * _winterRate + _winterServiceCharge;&#125; else &#123; charge = quantity * _summberRate;&#125;==&gt;if (notSummer(date)) &#123; charge = winterCharge(quantity);&#125; else &#123; charge = summerCharge(quantity);&#125; Consolidate Conditional Expression（合并条件表达式）你有一系列条件测试，都得到相同结果。（将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数） 123456789double disabilityAmount () &#123; if (_seniority &lt; 2) &#123; return 0;&#125; if (_monthsDisabled &gt; 12) &#123; return 0;&#125; if (_isPartTime) &#123; return 0;&#125;&#125;==&gt;double disabilityAmount() &#123; if (isNotEligibleForDisability()) &#123;return 0;&#125;&#125; Consolidate Duplicate Conditional Fragments（合并重复的条件片段）将下面这段重复代码搬移到条件表达式之外。 1234567891011121314if (isSpecialDeal()) &#123; total = price * 0.95; send();&#125; else &#123; total = price * 0.98; send();&#125;==&gt;if (isSpecialDeal()) &#123; total = price * 0.95;&#125; else &#123; total = price * 0.98;&#125;send(); Remove Control Flag（移除控制标记）以break语句或return语句取代控制标记 Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）函数中的条件逻辑使人难以看清正常的执行路径。（使用卫语句表现所有特殊情况） 1234567891011121314151617181920212223242526272829double getPayAmount() &#123; double result; if (_isDead) &#123; result = deadAmount(); &#125; else &#123; if (_isSeparated) &#123; result = separatedAmount(); &#125; else &#123; if (_isRetired) &#123; result = retiredAmount(); &#125; else &#123; result = normalPayAmount(); &#125; &#125; &#125;&#125;==&gt;double getPayAmount() &#123; if (_isDead) &#123; return deadAmount(); &#125; if (_isSeparated) &#123; return separatedAmount(); &#125; if (_isRetired) &#123; return retiredAmount(); &#125; return normalPayAmount();&#125; Replace Conditional with Polymorphism（以多态取代条件表达式）你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。（将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。） 12345678910111213141516double getSpeed() &#123; switch(_type) &#123; case EUROPEAN: return getBaseSpeed; case AFRICAN: return getBaseSpeed() - getLoadFactor() * _numberOfCoconuts; case NORWEGINA_BLUE: return (_isNailed) ? 0 : getBaseSpeed(_voltage); &#125; throw new RuntimeException(\"Should be unreachable\");&#125;==&gt;abstract class Bird &#123; abstract getSpeed()&#125;class European extends Bird &#123; getSpeed()&#125;class African extends Bird &#123; getSpeed()&#125;class NorwegianBlue extends Bird &#123; getSpeed()&#125; Introduce Null Object（引用Null对象）你需要再三检查某个对象是否为null。（将null值替换为null对象） 12345678if (customer == null) &#123; plan = BillingPlan.basic();&#125; else &#123; plan = customer.getPlan();&#125;==&gt;class Customer &#123; getPlan()&#125;class NullCustomer extends Customer &#123;getPlan()&#125; Introduce Assertion（引入断言）某一段代码需要对程序状态做出某种假设。以断言明确表现这种假设。 12345678double getExpenseLimit() &#123; return (_expenseLimit != NULL_EXPENSE) ? _expenseLimit : _primaryProject.getMemberExpenseLimit();&#125;==&gt;double getExpenseLimit() &#123; Assert.isTrue (_expenseLimit != NULL_EXPENSE || _primaryProject != null); return (_expenseLimit != NULL_EXPENSE) ? _expenseLimit : _primaryProject.getMemberExpenseLimit();&#125; 简化函数调用Rename Method（函数改名）函数的名称未能指示函数的用途。修改函数名称。 123class Customer &#123;getinvcdtlmt()&#125;==&gt;class Customer &#123;getInvoiceableCreditLimit()&#125; Add Parameter（添加函数）某个函数需要从调用端得到更多信息。（为些函数添加一个对象参数，让该对象带进函数所需的信息） Remove Parameter（移除参数）函数本体不再需要某个参数。将该参数去除。 Separate Query from Modifier（将查询函数和修改函数分离）某个函数既返回对象状态值，又修改对象状态。（建立两个不同的函数，其中一个负责查询，别一个负责修改。） 123456class Customer &#123;getTotalOutstandingAndSetReadyForSummaries()&#125;==&gt;class Customer &#123; getTotalOutstanding() setReadyForSummaries()&#125; Parameterize Method（令函数携带参数）若干函数做了类似的工作，但在函数本体中却包含了不同的值。（建立单一函数，以参数表达那些不同的值。） 12345678class Employee &#123; fivePercentRaise(); tenPercentRaise();&#125;==&gt;class Employee &#123; raise(percentage);&#125; Replace Parameter with Explicit Methods（以明确函数取代参数）你有一个函数，其中完全取决于参数值而采取不同行为。（针对该参数的每一个可能值，建立一个独立函数。） 123456789101112131415161718void setValue(String name, int value) &#123; if (name.equals(\"height\")) &#123; _height = value; return; &#125; if (name.equals(\"width\")) &#123; _width = value; return; &#125; Assert.shouldNeverReachHere();&#125;==&gt;void setHeight(int arg) &#123; _height = arg;&#125;void setWidth(int arg) &#123; _width = arg;&#125; Preserve Whole Object（保持对象完整）你从某个对象中取出若干值，将它们作为某一次函数调用的参数。改为传递整个对象。 12345int low = daysTempRange().getLow();int hight = daysTempRange().getHeight;withinPlan = plan.withinRange(low, hight);==&gt;withinPlan = plan.withinRange(daysTempRange()); Replace Parameter with Methods（以函数取代参数）对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。（让参数接受者去除该项参数，并直接调用前一个函数） 123456int basePrice = _quantity * _itemPrice;discountLevel = getDiscountLevel();double finalPrice = discountedPrice(basePrice, discountLevel);==&gt;int basePrice = _quantity * _itemPrice;double finalPrice = discountedPrice(basePrice); Introduce Parameter Object（引入参数对象）某些参数总是很自然地同时出现。以一个对象取代这些参数。 1234567891011class Customer &#123; amountInvoicedIn(start:Date, end: Date); amountReceived(start:Date, end: Date); amountOverdueln(start:Date, end: Date);&#125;==&gt;class Customer &#123; amountInvoicedIn(DateRange); amountReceived(DateRange); amountOverdueln(DateRange);&#125; Remove Setting Method（移除设值函数）类中的某个字段应该在对象创建时候被设值，然后就不再改变。（去掉该字段的所有设值函数） 12345class Employee &#123; Immutable; setImmutableValue()&#125;==&gt;class Employee &#123;&#125; Hide Method（隐藏函数）有一个函数，从来没有被其他任何类用到。（将这个函数修改为private） Replace Constructor with Factory Method（以工厂函数取代构造函数）你希望在创建对象时不仅仅是做简单的构建动作。（将构造函数替换为工厂函数。） 1234567Employee(int type) &#123; _type = type&#125;==&gt;static Employee create(int type) &#123; return new Employee(type);&#125; Encapsulate Downcast（封装向下转型）某个函数返回的对象，需要由函数调用者执行向下转型(downcast)。（将向下转型动作移到函数中） 1234567Object lastReading() &#123; return readings.lastElement();&#125;==&gt;Reading lastReading() &#123; return (Reading) readings.lastElement();&#125; Replace Error Code with Exception（以异常取代错误码）某个函数返回一个特定的代码，用以表示某种错误情况。（改用异常） 123456789101112131415int withdraw(int amount) &#123; if (amount &gt; _balance) &#123; return -1; &#125; else &#123; _balance -= amount; return 0; &#125;&#125;==&gt;void withdraw(int amount) throws BalanceException &#123; if (amount &gt; _balance) &#123; throw new BalanceException(); &#125; _balance -= amount;&#125; Replace Exception with Test（以测试取代异常）面对一个调用者可以预先检查的条件，你抛出了一个异常。(修改调用者，使它在调用函数之前先做检查) 1234567891011121314double getValueForPeriod(int periodNumber) &#123; try &#123; return _values[periodNumber]; &#125; catch(ArrayIndexOutOfBoundsException e) &#123; return 0; &#125;&#125;==&gt;double getValueForPeriod(int periodNumber) &#123; if (periodNumber &gt;= _values.length) &#123; return 0; &#125; return _values[periodNumber];&#125; 处理概括关系Pull Up Field（字段上移）两个子类拥有相同的字段。（将该字段移至超类） Pull Up Method（函数上移）有些函数，在各个子类中产生完全相同的结果。（将该函数移至超类） Pull Up Constructor Body（构造函数本体上移）你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。（在超类中新建一个构造函数，并在子类的构造函数中调用它） 123456789101112class Manager extends Employee &#123; public Manager(String name,String id,int grade) &#123; _name = name; _id = id; _grade = grade; &#125;&#125;==&gt;public Manager(String name, String id, int grade) &#123; super(name, id); _grade = grade;&#125; Push Down Method（函数下移）超类中的某个函数只与部分（而非全部）子类有关。（将这个函数移到相关子类去） Push Down Field（字段下移）超类中的某个字段只被部分（而非全部）子类用到。（将这个字段移到需要它的那些子类去） Extract Subclass（提炼子类）类中的某些特性只被某些（而非全部）实例用到。（新建一个子类，将上面所说的那一部分特性移到子类中） Extract SuperClass（提炼超类）两个类有相似特性。（为这两个类建立一个超类，将相同特性移至超类） Extract Interface（提炼接口）若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。（将相同的子集提炼到一个独立接口中） Collapse Hierarchy（折叠继承体系）超类和子类之间无太大区别。（将它们合为一体） Form Template Method（塑造模板函数）你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。（将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类） Replace Inheritance with Delegation（以委托取代继承）某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。（在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系） Replace Delegation with Inheritance（以继承取代委托）你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。（让委托类继承受托类） 大型重构Tease Apart Inheritance（梳理并分解继承体系）某个继承体系同时承担两项责任。（建立两个继承体系，并通过委托关系让其中一个可以调用另一个） Convert Procedural Design to Objects（将过程化设计转化为对象设计）你手上有一些传统过程化风格的代码。（将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中。） Separate Domain from Presentation（将领域和表述、显示分离）某些GUI类之中包含了领域逻辑。（将领域逻辑分离出来，为它们建立独立的领域类） 1234class OrderWindow &#123;&#125;==&gt;class OrderWindow&#123;&#125;class Order&#123;&#125; Extract Hierarchy（提炼继承体系）你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的。（建立继承体系，以一个子类表示一特殊情况）","tags":[{"name":"read","slug":"read","permalink":"yzbzz.github.io/tags/read/"}]},{"title":"android-okhttp-流程简析","date":"2017-03-10T06:51:38.000Z","path":"2017/03/10/android/android-okhttp-source/","text":"前言 OkHttp进行网络请求不是基于HttpURLConnection，而是基于socket。本篇只是对源码流程的简析。 源码分析Request 不熟悉如何使用OKHttp3的同学，可以先阅读android-okhttp章节 在使用OKHttp3进行网络请求时，我们会使用下面2种方式进行调用 1234567891011121314private final OkHttpClient client = new OkHttpClient();// 同步Response response = client.newCall(request).execute();// 异步client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125;&#125;); 从上面的代码可以看出，会先调用newCall(request)方法获取一个Call对象，再调用Call对象的excute方法或enqueue方法执行同步或异步请求。 接下来，我们来看看源码: 我们来看看newCall方法，该方法返回了一个RealCall对象 我们来看看execute和enqueue方法，我们可以看到这2个方法都用到了client.dispatcher()，这个方法得到的是一个Dispatcher对象，如下图： Dispatcher类设置了一个最大的请求数，定义了一些双队列用于存储request请求，同时定义了一个ExecutorService线程池用于执行异步请求。我们来看看Dispatcher的enqueue方法 在Dispatcher的enqueue方法中，会使用创建的线程池执行AsyncCall，我们再来看看AsyncCall的实现 大家看图中标红的地方，是不是和我们RealCall同步execute方法很像，都是调用了getResponseWithInterceptorChain方法返回response，而且我们也可以知道onFailure和onResponse回调的逻辑了 我们再来持看getResponseWithInterceptorChain方法 在getResponseWithInterceptorChain方法内部，会定义一个List，装载你自己定义的拦截器和一些Okhttp3定义的拦截器，最后会调用RealInterceptorChain类的proceed方法去递归调用List中的拦截器的intercept方法， 我们来看看ConnectInterceptor拦截器，通过名字我们大概能知道是做网络连接用的。 在ConnectInterceptor的intercept方法中会用调用StreamAllocation类的newStream获取HttpStream对象，调用connection方法得到RealConnection对象，在connection方法里面仅仅是返回了一个对象，那么RealConnection对象是怎么生成的呢，我们大概可以猜到是在newStream里生成的。我们来看看newStream方法 在方法内部，大家可以看到是调用了findHealthyConnection方法获取到了RealConnection对象，同时会把RealConnection的数据(source/sink)存放在Http1xStream OR Http2xStream中(大家先记住这一点，后面获取Reaponse时会用到Http1xStream或Http2xStream的数据)。在方法findHealthyConnection内部，会调用findConnection方法 在findConnection方法内部，最终会调到193行的connect方法，接下来，我们看看RealConnection的connect方法。 在connect方法的内部，最终会调用buildTunneledConnection或buildConnection方法，这2个方法最终都会调用RealConnection的connectSocket方法和establishProtocol方法。在connectSocket方法内部，会进行socket进行数据传输，在establishProtocol方法内部，会使用Okio进行数据流的读取，并给RealConnection的source和sink进行赋值，这个值会存储在后续Response的body中。 从上图可以看出，在connectSocket内部，会调用Platform的get方法获取相应平台，并调用Platform的connectSocket方法进行socket连接。 至此，我们知道了Okhttp3是通过socket进行数据传输的，同时request请求大致也清楚了 源码分析Response在上面的Request分析篇中，大家还记得，在RealCall的getResponseWithInterceptorChain方法吗 我们在这个方法分析了ConnectInterceptor拦截器中的网络请求流程，在这个方法的最后，会调用CallServerInterceptor拦截器去进行Response的结果获取，接下来，我们来看看CallServerInterceptor 大家看第62行，Response的body就是在这赋值的，这里的httpStream就是我们Request篇叫大家记住的Http1xStream或Http2xStream，这2种httpStream流程差不多，我们这里以Http1xStream为例来分析 这里比较简单，调用openResponseBody返回一个RealResponseBody对象返回，在方法内部先调用getTransferStream方法获取一个source对象，然后生成一个RealResponseBody对象进行返回。熟悉Okhttp3用法的同学应该知道，在onResponse回调里，我们会使用response.body.string()获取字符串或response.body.byteStream()获取流对象。通过上面对CallServerInterceptor拦截器的分析(第62行)，我们知道response.body就是调用httpStream的openResponseBody方法返回的RealResponseBody，我们再来看看RealResponseBody类 通过上面的源码，我们可以看出，其它就是调用了source的一些方法进行数据处理，然后返回，这里的source就是我们Request分析篇中RealConnection的source 至此，response整个流程也大致清楚了","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"Android配置文件详解-Activity","date":"2017-02-23T03:00:18.000Z","path":"2017/02/23/android/android-config-activity/","text":"Activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;activity android:allowEmbedded=[\"true\" | \"false\"] android:allowTaskReparenting=[\"true\" | \"false\"] android:alwaysRetainTaskState=[\"true\" | \"false\"] android:alwaysRetainTaskState=[\"true\" | \"false\"] android:autoRemoveFromRecents=[\"true\" | \"false\"] android:banner=”drawable resource” android:clearTaskOnLaunch=[\"true\" | \"false\"] android:configChanges=[\"mcc\", \"mnc\", \"locale\", \"touchscreen\", \"keyboard\", \"keyboardHidden\", \"navigation\", \"screenLayout\", \"fontScale\", \"uiMode\", \"orientation\",\"screenSize\", \"smallestScreenSize\"] android:documentLaunchMode=[\"intoExisting\" | \"always\" | “none” | “never”] android:enabled=[\"true\" | \"false\"] android:excludeFromRecents=[\"true\" | \"false\"] android:exported=[\"true\" | \"false\"] android:finishOnTaskLaunch=[\"true\" | \"false\"] android:hardwareAccelerated=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:label=\"string resource\" android:launchMode=[\"standard\" | \"singleTop\" | \"singleTask\" | \"singleInstance\"] android:maxRecents=\"integer\" android:multiprocess=[\"true\" | \"false\"] android:name=\"string\" android:noHistory=[\"true\" | \"false\"] android:parentActivityName=\"string\" android:permission=\"string\" android:process=\"string\" android:relinquishTaskIdentity=[\"true\" | \"false\"] android:resizeableActivity=[\"true\" | \"false\"] android:screenOrientation=[\"unspecified\" | \"behind\" | \"landscape\" | \"portrait\" | \"reverseLandscape\" | \"sensorLandscape\" | \"sensorPortrait\" | \"userLandscape\" | \"userPortrait\" | \"sensor\" | \"fullSensor\" | \"nosensor\"] \"user\" | \"fullUser\" | \"locked\" android:stateNotNeeded=[\"true\" | \"false\"] android:supportsPictureInPicture=[\"true\" | \"false\"] android:taskAffinity=\"string\" android:theme=\"resource or theme\" android:uiOptions=[\"none\" | \"splitActionBarWhenNarrow\"] android:windowSoftInputMode=[\"stateUnspecified\", \"stateUnchanged\", \"stateHidden\", \"stateAlwaysHidden\", \"stateVisible\", \"stateAlwaysVisible\", \"adjustUnspecified\", \"adjustResize\", \"adjustPan\"] &gt; &lt;/activity&gt; android:allowEmbedded=[“true” | “false”]**这个标识一般为开发可穿戴设备时使用，表示该 Activity 可作为另一 Activity 的嵌入式子项启动。 它尤其适用于子项所在的容器（如 Display）为另一 Activity 所拥有的情况。 例如，用于 Wear 自定义通知的 Activity 必须声明此项，以便 Wear 在其上下文流中显示 Activity，后者位于另一进程中。该属性的默认值为 false。 android:allowTaskReparenting=[“true” | “false”]这个标示和 Application 的标识意义一样，所以如果同时声明该标识，这个标识会覆盖 Application 的标识 android:alwaysRetainTaskState这个标识用来指示系统是否始终保持 Activity 所在任务的状态 —“true”表示保持，“false”表示允许系统在特定情况下将任务重置到其初始状态。 默认值为“false”。该属性只对任务的根 Activity 有意义；对于所有其他 Activity，均忽略该属性。正常情况下，当用户从主屏幕重新选择某个任务时，系统会在特定情况下清除该任务（从根 Activity 之上的堆栈中移除所有 Activity）。 系统通常会在用户一段时间（如 30 分钟）内未访问任务时执行此操作。不过，如果该属性的值是“true”，则无论用户如何到达任务，将始终返回到最后状态的任务。 例如，在网络浏览器这类存在大量用户不愿失去的状态（如多个打开的标签）的应用中，该属性会很有用。 android:autoRemoveFromRecents=[“true” | “false”]这个标识为 API21 版本添加，由具有该属性的 Activity 启动的任务是否一直保留在概览屏幕中，直至任务中的最后一个 Activity 完成为止。 若为 true，则自动从概览屏幕中移除任务。 它会替换调用方使用的 FLAG_ACTIVITY_RETAIN_IN_RECENTS。 它必须是布尔值“true”或“false”。 android:banner=”drawable resource”这个和 application 里面的 banner 标识一样，也是用在 android TV 上的 android:clearTaskOnLaunch这个标识用来指明当应用从主屏幕重新启动时是否都从中移除除根 Activity 之外的所有 Activity，true 表示始终将任务清除到只剩其根 Activity，false 表示不清除，默认值为 false。需要注意的是该属性只对启动新任务的 Activity（根 Activity）有意义；对于任务中的所有其他 Activity，均忽略该属性。当值为“false”时，可在某些情况下清除任务中的 Activity（参考结合 alwaysRetainTaskState 属性），但并非一律可以。如果该属性和 allowTaskReparenting 的值均为“true”，则如上所述，任何可以更改父项的 Activity 都将转移到与其有亲和关系的任务；其余 Activity 随即被移除。例如，假定有人从主屏幕启动了 Activity P，然后从那里转到 Activity Q。该用户接着按了主屏幕按钮，然后返回到 Activity P。正常情况下，用户将看到 Activity Q，因为那是其最后在 P 的任务中执行的 Activity。 不过，如果 P 将此标志设置为“true”，则当用户按下主屏幕将任务转入后台时，其上的所有 Activity（在本例中为 Q）都会被移除。 因此用户返回任务时只会看到 P。 android:configChanges列出 Activity 将自行处理的配置更改。在运行时发生配置更改时，默认情况下会关闭 Activity 然后将其重新启动，但使用该属性声明配置将阻止 Activity 重新启动。 Activity 反而会保持运行状态，并且系统会调用其 onConfigurationChanged() 方法。以下为该属性的值，多个值使用“|”分隔 — 例如，“locale|navigation|orientation”：| Value | Description || ——————– | —————————————- || “mcc” | IMSI 移动国家/地区代码 (MCC) 发生了变化 - 检测到了 SIM 并更新了 MCC。 || “mnc” | IMSI 移动网络代码 (MNC) 发生了变化 - 检测到了 SIM 并更新了 MNC。 || locale” | 语言区域发生了变化 — 用户为文本选择了新的显示语言。 || “touchscreen” | 触摸屏发生了变化。（这种情况通常永远不会发生。） || “keyboard” | 键盘类型发生了变化 — 例如，用户插入了一个外置键盘。 || “keyboardHidden” | 键盘无障碍功能发生了变化 — 例如，用户显示了硬件键盘。 || “navigation” | 导航类型（轨迹球/方向键）发生了变化。（这种情况通常永远不会发生。） || “screenLayout” | 屏幕布局发生了变化 — 这可能是由激活了其他显示方式所致。 || “fontScale” | 字体缩放系数发生了变化 — 用户选择了新的全局字号。 || “uiMode” | 用户界面模式发生了变化 — 这可能是因用户将设备放入桌面/车载基座或夜间模式发生变化所致。 请参阅 UiModeManager。 此项为 API 级别 8 中新增配置。 || “orientation” | 屏幕方向发生了变化 — 用户旋转了设备。 注：如果您的应用面向 API 级别 13 或更高级别（按照 minSdkVersion 和 targetSdkVersion 属性所声明的级别），则还应声明 “screenSize” 配置，因为当设备在横向与纵向之间切换时，该配置也会发生变化。 || “screenSize” | 当前可用屏幕尺寸发生了变化。它表示当前可用尺寸相对于当前纵横比的变化，因此会在用户在横向与纵向之间切换时发生变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。此项为 API 级别 13 中新增配置。 || “smallestScreenSize” | 物理屏幕尺寸发生了变化。它表示与方向无关的尺寸变化，因此只有在实际物理屏幕尺寸发生变化（如切换到外部显示器）时才会变化。对此配置的变更对应于smallestWidth 配置的变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。此项为 API 级别 13 中新增配置。 || “layoutDirection” | 布局方向发生了变化。例如，从从左至右 (LTR) 更改为从右至左 (RTL)。 此项为 API 级别 17 中新增配置。 |所有这些配置变更都可能影响应用看到的资源值。 因此，调用 onConfigurationChanged() 时，通常有必要再次获取所有资源（包括视图布局、可绘制对象等），以正确处理变化。 我们平常接触到最多的就是屏幕的旋转，屏幕的旋转如果在没有特殊设置的情况下会销毁当前的 Activity 重新创建一个新的，为了避免创建新的，就可以在 AndroidMainfest.xml 中对指定 Activity 对应的 配置android:configChanges=”orientation”，这样，每次旋转方向时，只有 onConfigurationChanged 方法被调用，没有了销毁重建的过程。 android:documentLaunchMode=[“intoExisting” | “always” | “none” | “never”]指定每次启动任务时应如何向其中添加新的 Activity 实例。 该属性允许用户让多个来自同一应用的文档出现在概览屏幕（recent app）中。该属性有四个值，会在用户使用该应用打开文档时产生以下效果： Value Description “intoExisting” Activity 会为文档重复使用现有任务。使用该值与不设置 FLAG_ACTIVITY_MULTIPLE_TASK 标志、但设置 FLAG_ACTIVITY_NEW_DOCUMENT 标志所产生的效果相同，如使用 Intent 标志添加任务中所述。 “always” Activity 为文档创建新任务，即便文档已打开也是如此。 这与同时设置 FLAG_ACTIVITY_NEW_DOCUMENT 和 FLAG_ACTIVITY_MULTIPLE_TASK 标志的效果相同。 “none” 该 Activity 不会为 Activity 创建新任务。这是默认值，它只会在设置了 FLAG_ACTIVITY_NEW_TASK 时创建新任务。 概览屏幕将按其默认方式对待此 Activity：为应用显示单个任务，该任务将从用户上次调用的任意 Activity 开始继续执行。 “never” 即使 Intent 包含 FLAG_ACTIVITY_NEW_DOCUMENT，该 Activity 也不会启动到新文档之中。 设置此值会替代 FLAG_ACTIVITY_NEW_DOCUMENT 和 FLAG_ACTIVITY_MULTIPLE_TASK 标志的行为（如果在 Activity 中设置了其中一个标志），并且概览屏幕将为应用显示单个任务，该任务将从用户上次调用的任意 Activity 开始继续执行。 注：对于除“none”和“never”以外的值，必须使用 launchMode=”standard” 定义 Activity。 如果未指定此属性，则使用 documentLaunchMode=”none”。 android:enabled=[“true” | “false”]该属性用来标示系统是否可将 Activity 实例化 — “true” 表示可以，“false”表示不可以。 默认值为“true”。上面提到了 元素具有自己的 enabled 属性，该属性适用于所有应用组件，包括 Activity。 和 属性必须都是“true”（因为它们都默认使用该值），系统才能将 Activity 实例化。 如果任何一个属性是“false”，则无法进行实例化。 android:excludeFromRecents该标识用来标示是否应将该 Activity 启动的任务排除在最近使用的应用列表（即概览屏幕）之外。 也就是说，当该 Activity 是新任务的根 Activity 时，此属性确定任务是否应出现在最近使用的应用列表中。 如果应将任务排除在列表之外，请设置“true”；如果应将其包括在内，则设置“false”。 默认值为“false”。 android:exported=[“true” | “false”]该标识用来指明Activity 是否可由其他应用的组件启动 —“true”表示可以，“false”表示不可以。若为“false”，则 Activity 只能由同一应用的组件或使用同一用户 ID 的不同应用启动。需要注意的是该默认值取决于 Activity 是否包含 Intent 过滤器。没有任何过滤器意味着 Activity 只能通过指定其确切的类名称进行调用。 这意味着 Activity 专供应用内部使用（因为其他应用不知晓其类名称）。 因此，在这种情况下，默认值为“false”。另一方面，至少存在一个过滤器意味着 Activity 专供外部使用，因此默认值为“true”。该属性并非限制 Activity 对其他应用开放度的唯一手段。 您还可以利用权限来限制哪些外部实体可以调用 Activity。 android:finishOnTaskLaunch该标识用来标示每当用户再次启动其任务（在主屏幕上选择任务）时，是否应关闭（完成）现有 Activity 实例 —“true”表示应关闭，“false”表示不应关闭。 默认值为“false”。如果该属性和 allowTaskReparenting 均为“true”，则优先使用该属性。 Activity 的亲和关系会被忽略。 系统不是更改 Activity 的父项，而是将其销毁。 android:hardwareAccelerated=[“true” | “false”]该标识用来表明是否应为此 Activity 启用硬件加速渲染 —“true”表示应启用，“false”表示不应启用，默认值为“false”。和 application 的标识不一样的是，该标示只针对 Activity。从 Android 3.0 开始，为应用提供了硬件加速 OpenGL 渲染器，以改善许多常见 2D 图形运算的性能。 启用硬件加速渲染器时，Canvas、Paint、Xfermode、ColorFilter、Shader 和 Camera 中的大多数运算都会得到加速。这可以提高动画、滚动的流畅度和总体响应速度，即便是并不明确使用框架 OpenGL 库的应用也会受益。 由于启用硬件加速会增加资源消耗，因此您的应用将占用更多内存。需要注意的是，并非所有 OpenGL 2D 运算都会得到加速。如果您启用硬件加速渲染器，请对应用进行测试，以确保其在利用渲染器时不会出错。 android:icon一个表示 Activity 的图标。该图标会在需要在屏幕上表示 Activity 时显示给用户。 例如，代表启动任务的 Activity 的图标显示在启动器窗口中。该图标通常附带标签（请参阅 android:label 属性）。必须将该属性设置为对包含图像定义的可绘制资源的引用。 如果未设置该属性，则改为使用为应用整体指定的图标（请参阅 元素的 icon 属性），activity 的该属性会覆盖 application 的该属性。这个 Activity 的图标 — 无论设置于此处还是由 元素设置 — 同时也是 Activity 所有 Intent 过滤器的默认图标（请参阅 元素的 icon 属性）。 android:label=”string resource”一种可由用户读取的 Activity 标签。该标签会在必须将 Activity 呈现给用户时显示在屏幕上。 它通常与 Activity 图标一并显示。如果未设置该属性，则改为使用为应用整体设置的标签（请参阅 元素的 label 属性），activity 的该属性会覆盖 application 的该属性。这个 Activity 的标签 — 无论设置于此处还是由 元素设置 — 同时也是 Activity 所有 Intent 过滤器的默认标签（请参阅 元素的 label 属性）。应将该标签设置为对字符串资源的引用，以便可以像用户界面中的其他字符串那样进行本地化。不过，为便于开发应用，也可将其设置为原始字符串。 android:launchMode(Activity加载模式)在多Activity开发中，有可能是自己应用之间的Activity跳转，或者夹带其他应用的可复用Activity。可能会希望跳转到原来某个Activity实例，而不是产生大量重复的Activity。这需要为Activity配置特定的加载模式，而不是使用默认的加载模式 Activity有四种加载模式： standard、singleTop、singleTask、singleInstance(其中前两个是一组、后两个是一组)，默认为standard standard：就是intent将发送给新的实例，所以每次跳转都会生成新的activity。 singleTop：也是发送新的实例，但不同standard的一点是，在请求的Activity正好位于栈顶时(配置成singleTop的Activity)，不会构造新的实例 singleTask：和后面的singleInstance都只创建一个实例，当intent到来，需要创建设置为singleTask的Activity的时候，系统会检查栈里面是否已经有该Activity的实例。如果有直接将intent发送给它。 singleInstance：首先说明一下task这个概念，Task可以认为是一个栈，可放入多个Activity。比如启动一个应用，那么Android就创建了一个Task，然后启动这个应用的入口Activity，那在它的界面上调用其他的Activity也只是在这个task里面。那如果在多个task中共享一个Activity的话怎么办呢。举个例来说，如果开启一个导游服务类的应用程序，里面有个Activity是开启GOOGLE地图的，当按下home键退回到主菜单又启动GOOGLE地图的应用时，显示的就是刚才的地图，实际上是同一个Activity，实际上这就引入了singleInstance。singleInstance模式就是将该Activity单独放入一个栈中，这样这个栈中只有这一个Activity，不同应用的intent都由这个Activity接收和展示，这样就做到了共享。当然前提是这些应用都没有被销毁，所以刚才是按下的HOME键，如果按下了返回键，则无效 android:maxRecents=”integer”该标识用来指明概览屏幕中位于此 Activity 根位置的任务数上限。 达到该条目数时，系统会从概览屏幕中移除最近最少使用的实例。 有效值为 1-50（低内存设备使用 25）；0 为无效值。 该值必须是整数，例如 50。默认值为 16。 android:multiprocess该标识用来指明是否可以将 Activity 实例启动到启动该实例的组件进程内 —“true”表示可以，“false”表示不可以。默认值为“false”。正常情况下，新的 Activity 实例会启动到定义它的应用进程内，因此所有 Activity 实例都在同一进程内运行。 不过，如果该标志设置为“true”，Activity 实例便可在多个进程内运行，这样系统就能在任何使用实例的地方创建实例（前提是权限允许这样做），但是貌似使用的场景和案例不是很多。 android:name=”string”该标识应该不用介绍了，用来指定 Activity 的类的名称，是 Activity 的子类。 该属性值应为完全限定类名称（例如，“com.example.project.DemoActivity”）。不过，为了简便起见，如果名称的第一个字符是句点（例如，“.DemoActivity”），则名称将追加到 元素中指定的软件包 com.example.project 名称之后。还有一个需要注意的是，应用一旦发布，即不应更改该名称（除非您设置了 android:exported=”false”），也就是说如果您的 Activity 有让其他应用使用到，那么最好不要修改名字，因为有可能其他应用是通过显式的方式指定的 Activity 名字，修改名字可能会造成其他应用无法正常使用甚至崩溃。该标识没有默认值。必须指定该名称。 android:noHistory当用户离开 Activity 并且其在屏幕上不再可见时，是否应从 Activity 堆栈中将其移除并完成（调用其 finish() 方法）—“true”表示应将其完成，“false”表示不应将其完成。 默认值为“false”。“true”一值表示 Activity 不会留下历史轨迹。 它不会留在任务的 Activity 堆栈内，因此用户将无法返回 Activity。 所以有一点需要特别注意的是，在此情况下，如果从这个定义了 noHistory 的 Activity 启动另一个 Activity 来获取它的结果，系统永远不会调用 onActivityResult()，因为此时这个 Activity 已经关闭了。 android:parentActivityName=”string”Activity 逻辑父项的类名称。此处的名称必须与为相应 元素的 android:name 属性指定的类名称一致。系统会读取该属性，以确定当用户按下操作栏中的“向上”按钮时应该启动哪一个 Activity。 系统还可以利用这些信息通过 TaskStackBuilder 合成 Activity 的返回栈关于向上导航的详细信息，可以看看 Providing Up Navigation android:permission=”string”参见android permission 1 和 android permission 2 android:process=”string”应在其中运行 Activity 的进程的名称。正常情况下，应用的所有组件都在为应用创建的默认进程名称内运行，您无需使用该属性。 但在必要时，您可以使用该属性替换默认进程名称，以便让应用组件散布到多个进程中。如果为该属性分配的名称以冒号（“:”）开头，则会在需要时创建应用专用的新进程，并且 Activity 会在该进程中运行。如果进程名称以小写字符开头，Activity 将在该名称的全局进程中运行，前提是它拥有相应的权限。这可以让不同应用中的组件共享一个进程，从而减少资源占用。上面提到的 Application 元素的 process 属性可为所有组件设置一个不同的默认进程名称。 android:relinquishTaskIdentityActivity 是否将其任务标识符交给任务栈中在其之上的 Activity。 如果任务根 Activity 的该属性设置为“true”，则任务会用其内的下一个 Activity 的 Intent 替换基本 Intent。 如果下一个 Activity 的该属性也设置为“true”，则该 Activity 会将基本 Intent 给予其在同一任务中启动的任何 Activity。 系统继续为每个 Activity 执行此过程，直至遇到的某个 Activity 将该属性设置为“false”为止。 默认值为“false”。还有一个很有意思的功能是，如果该属性设置为“true”，则 Activity 还可利用 ActivityManager.TaskDescription 来更改概览屏幕中的标签、颜色和图标。 android:resizeableActivity=[“true” | “false”]这个标识和 里面的作用一样，如果在 activity 里面定义的话则代表这个 activity 是否支持分屏模式。如果您将该属性设置为 true，则用户可以分屏和自由形状模式启动 Activity。 如果您将该属性设置为 false，Activity 将不支持多窗口模式。 如果该值为 false，且用户尝试在多窗口模式下启动 Activity，该 Activity 将全屏显示。该属性是在 API 级别 24 添加的，如果您的应用面向 API 级别 24 或更高级别，但未对该属性指定值，则该属性的值默认设为 true。 android:screenOrientationActivity 在设备上的显示方向。如果 Activity 是在多窗口模式下运行，系统会忽略该属性。它的取值可以是如下：| Value | Description || —————— | —————————————- || “unspecified” | 默认值。由系统选择方向。在不同设备上，系统使用的政策以及基于政策在特定上下文所做的选择可能有所差异。 || “behind” | 与 Activity 栈中紧接着它的 Activity 的方向相同。 || “landscape” | 横向方向（显示的宽度大于高度）。 || “portrait” | 纵向方向（显示的高度大于宽度）。 || “reverseLandscape” | 与正常横向方向相反的横向方向。API 级别 9 中的新增配置。 || “reversePortrait” | 与正常纵向方向相反的纵向方向。API 级别 9 中的新增配置。 || “sensorLandscape” | 横向方向，但根据设备传感器，可以是正常或反向的横向方向。API 级别 9 中的新增配置。 || “sensorPortrait” | 纵向方向，但根据设备传感器，可以是正常或反向的纵向方向。API 级别 9 中的新增配置。 || “userLandscape” | 横向方向，但根据设备传感器和用户的传感器首选项，可以是正常或反向的横向方向。 如果用户锁定了基于传感器的旋转，其行为与 landscape 相同，否则，其行为与 sensorLandscape 相同。API 级别 18 中的新增配置。 || “userPortrait” | 纵向方向，但根据设备传感器和用户的传感器首选项，可以是正常或反向的纵向方向。 如果用户锁定了基于传感器的旋转，其行为与 portrait 相同，否则，其行为与 sensorPortrait 相同。API 级别 18 中的新增配置。 || “sensor” | 方向由设备方向传感器决定。显示方向取决于用户如何手持设备，它会在用户旋转设备时发生变化。 但一些设备默认情况下不会旋转到所有四种可能的方向。要允许全部四种方向，请使用 “fullSensor”。 || “fullSensor” | 方向由 4 种方向中任一方向的设备方向传感器决定。这与 “sensor” 类似，不同的是它允许所有 4 种可能的屏幕方向，无论设备正常情况下采用什么方向（例如，一些设备正常情况下不使用反向纵向或反向横向，但它支持这些方向）。 API 级别 9 中的新增配置。 || “nosensor” | 决定方向时不考虑物理方向传感器。传感器会被忽略，因此显示不会随用户对设备的移动而旋转。 除了这个区别，系统在选择方向时使用的政策与“unspecified”设置相同。 || “user” | 用户当前的首选方向。 || “fullUser” | 如果用户锁定了基于传感器的旋转，其行为与 user 相同，否则，其行为与 fullSensor 相同，允许所有 4 种可能的屏幕方向。 API 级别 18 中的新增配置。 || “locked” | 将方向锁定在其当前的任意旋转方向。API 级别 18 中的新增配置。 | 注：如果您声明其中一个横向或纵向值，系统将其视为对 Activity 运行方向的硬性要求。 因此，您声明的值支持通过 Google Play 之类的服务进行过滤，这样就能将您的应用只提供给支持 Activity 所要求方向的设备。 例如，如果您声明了 “landscape”、”reverseLandscape” 或 “sensorLandscape”，则您的应用将只提供给支持横向方向的设备。 不过，您还应通过 元素明确声明，您的应用要求采用纵向或横向方向。 例如，。这纯粹是 Google Play（以及其他支持它的服务）提供的一种过滤行为，平台本身并不能控制当设备仅支持特定方向时您的应用能否安装 android:stateNotNeeded该标识用来指明能否在不保存 Activity 状态的情况下将其终止并成功重新启动 —“true”表示可在不考虑其之前状态的情况下重新启动，“false”表示需要之前状态，默认值为“false”。一般情况下，为保存资源而暂时关闭 Activity 前，系统会调用 onSaveInstanceState() 方法，该方法将 Activity 的当前状态存储在一个 Bundle 对象中，然后在 Activity 重新启动时将其传递给 onCreate() 。如果该属性设置为 true，系统可能不会调用 onSaveInstanceState()，并且会向 onCreate() 传递 null 而不是 Bundle，这样就与它在 Activity 首次启动时完全一样。这个标识又一个特别有用的地方是，true 设置可确保 Activity 能够在未保留状态时重新启动。 例如，显示主屏幕的 Activity 可以使用该设置来确保其由于某种原因崩溃时不会被移除。 android:supportsPictureInPicture=[“true” | “false”]指定 Activity 是否支持画中画显示，设置该属性的同时，需要将 android:resizeableActivity 标识设置为 true，要不然系统会忽略该属性，可以看到设置完该属性之后，android TV 就可以实现手机端一个悬浮 activity 的效果，类似于 youtube 。所以同样这个标识和 android:resizeableActivity 一样都是 API24 版本添加的。 android:taskAffinity=”string”这个标识用来指明一个 Activity 的亲和性，使用方案可以看看我的博客：android深入解析Activity的launchMode启动模式，Intent Flag，taskAffinity。从概念上讲，具有相同亲和关系的 Activity 归属同一任务（从用户的角度来看，则是归属同一“应用”）。 任务的亲和关系由其根 Activity 的亲和关系确定。亲和关系确定两件事 - Activity 更改到的父项任务（请参阅上面提到的 allowTaskReparenting 属性）和通过 FLAG_ACTIVITY_NEW_TASK 标志启动 Activity 时将用来容纳它的任务。默认情况下，应用中的所有 Activity 都具有相同的亲和关系。您可以设置该属性来以不同方式组合它们，甚至可以将在不同应用中定义的 Activity 置于同一任务内。 要指定 Activity 与任何任务均无亲和关系，请将其设置为空字符串。如果未设置该属性，则 Activity 继承为应用设置的亲和关系（可以参考 元素的 taskAffinity 属性），应用默认亲和关系的名称是 元素设置的 packageName。 android:theme=”resource or theme”这个标识用的应该很多了，用来定义一个 activity 的样式，为一个资源的引用，它会自动将 Activity 的上下文设置为使用该主题（请参阅 setTheme()），它还可以引发 Activity 启动前的“启动”动画（以更加符合 Activity 的实际外观）。如果未设置该属性，则 Activity 继承通过 application 元素的 theme 属性为应用整体设置的主题。 如果该属性也未设置，则使用默认系统主题。 android:uiOptions=[“none” | “splitActionBarWhenNarrow”]这个标识主要是用来针对 action bar 的，它有两个值： Value Description “none” 无附加 UI 选项。这是默认值。 “splitActionBarWhenNarrow” 当水平空间受限时（例如在手持设备上的纵向模式下时）在屏幕底部添加一个栏以显示应用栏（也称为操作栏）中的操作项）。 应用栏不是以少量操作项形式出现在屏幕顶部的应用栏中，而是分成了顶部导航区和底部操作项栏。 这可以确保操作项以及顶部的导航和标题元素都能获得合理的空间。 菜单项不会拆分到两个栏中，它们始终一起出现。 android:windowSoftInputModeactivity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题，Android1.5后的一个新特性。这个属性能影响两件事情： 当 Activity 成为用户注意的焦点时软键盘的状态 — 隐藏还是可见 对 Activity 主窗口所做的调整 — 是否将其尺寸调小以为软键盘腾出空间，或者当窗口部分被软键盘遮挡时是否平移其内容以使当前焦点可见各值的含义： stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置 stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示 stateHidden：用户选择activity时，软键盘总是被隐藏 stateAlwaysHidden：当用户选择 Activity 时 — 也就是说，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时 — 隐藏软键盘。（当该Activity主窗口获取焦点时，软键盘也总是被隐藏的） stateVisible：软键盘通常是可见的 stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态 adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示 adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间 adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分 adjustResize 和 adjustPan 的区别就在于前者是调整 Activity 的窗口尺寸来达到适配的目的，而 adjustPan 仅仅只是将窗口平移，界面的一部分就会被软键盘覆盖住，就不会被挤到软键盘之上了。","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"Android配置文件详解-AndroidManifest","date":"2017-02-22T03:51:47.000Z","path":"2017/02/22/android/android-config-am/","text":"AndroidManifest 每个应用的根目录中都必须包含一个AndroidManifest.xml文件(且文件名精确无误)。AndroidManifest向Android系统提供应用的必要信息，系统必须具备有这些信息方可运行应用的任何代码。此外，AndroidManifest还可执行以下操作 为应用的Java软件包命名。软件包名称充当应用的唯一标识符。 描述应用的各个组件，包括构成应用的 Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的 Intent 消息。这些声明向 Android 系统告知有关组件以及可以启动这些组件的条件的信息。 确定托管应用组件的进程。 声明应用必须具备哪些权限才能访问 API 中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限。 列出 Instrumentation 类，这些类可在应用运行时提供分析和其他信息。这些声明只会在应用处于开发阶段时出现在清单中，在应用发布之前将移除。 声明应用所需的最低 Android API 级别 列出应用必须链接到的库 注：准备要在 Chromebook 上运行的 Android 应用时，要考虑一些重要的硬件和软件功能限制。如需了解详细信息，请参阅 Chromebook 的应用清单兼容性文档。 AndroidManifest文件结构下面是AndroidManifest文件的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest&gt; &lt;uses-permission /&gt; &lt;permission /&gt; &lt;permission-tree /&gt; &lt;permission-group /&gt; &lt;instrumentation /&gt; &lt;uses-sdk /&gt; &lt;uses-configuration /&gt; &lt;uses-feature /&gt; &lt;supports-screens /&gt; &lt;compatible-screens /&gt; &lt;supports-gl-texture /&gt; &lt;application&gt; &lt;meta-data /&gt; &lt;activity&gt; &lt;intent-filter&gt; &lt;action /&gt; &lt;category /&gt; &lt;data /&gt; &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity&gt; &lt;activity-alias&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/activity-alias&gt; &lt;service&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/service&gt; &lt;receiver&gt; &lt;intent-filter&gt; . . . &lt;/intent-filter&gt; &lt;meta-data /&gt; &lt;/receiver&gt; &lt;provider&gt; &lt;grant-uri-permission /&gt; &lt;meta-data /&gt; &lt;path-permission /&gt; &lt;/provider&gt; &lt;uses-library /&gt; &lt;/application&gt;&lt;/manifest&gt; AndroidManifest属性Application1234567891011121314151617181920212223242526272829303132333435363738&lt;application android:allowBackup=[\"true\" | \"false\"] android:allowClearUserData=[\"true\" | \"false\"] android:allowTaskReparenting=[\"true\" | \"false\"] android:backupAgent=\"string\" android:backupInForeground=[\"true\" | \"false\"] android:banner=\"drawable resource\" android:debuggable=[\"true\" | \"false\"] android:description=\"string resource\" android:enabled=[\"true\" | \"false\"] android:extractNativeLibs=[\"true\" | \"false\"] android:fullBackupContent=\"string\" android:fullBackupOnly=[\"true\" | \"false\"] android:hasCode=[\"true\" | \"false\"] android:hardwareAccelerated=[\"true\" | \"false\"] android:isGame=[\"true\" | \"false\"] android:icon=\"drawable resource\" android:killAfterRestore=[\"true\" | \"false\"] android:label=\"string resource\" android:largeHeap=[\"true\" | \"false\"] android:logo=\"drawable resource\" android:manageSpaceActivity=\"string\" android:name=\"string\" android:permission=\"string\" android:persistent=[\"true\" | \"false\"] android:process=\"string\" android:restoreAnyVersion=[\"true\" | \"false\"] android:requiredAccountType=\"string\" android:resizeableActivity=[\"true\" | \"false\"] android:restrictedAccountType=\"string\" android:supportsRtl=[\"true\" | \"false\"] android:taskAffinity=\"string\" android:testOnly=[\"true\" | \"false\"] android:theme=\"resource or theme\" android:uiOptions=[\"none\" | \"splitActionBarWhenNarrow\"] android:usesCleartextTraffic=[\"true\" | \"false\"] android:vmSafeMode=[\"true\" | \"false\"]&gt;&lt;/application&gt; android:allowBackup开启或关闭应用程序数据的备份和恢复功能，注意该属性值默认为true，如果你不需要你的应用被恢复导致隐私数据暴露（如果值为true，甚至可以直接通过adb命令获取该应用中的数据），必须手动设置此属性1234567891011// 备份adb backup -nosystem -noshared -apk -f d:/com.test.bak.ab com.test.bak-nosystem: 不备份系统应用-noshared: 不备份应用存储在SD中的数据-apk: 备份应用APK安装包-f d:/com.test.bak.ab: 备份文件在PC上的路径com.test.bak: 要备份的包名// 恢复adb restore d:/com.test.bak.ab android:allowClearUserData默认为true。用户是否能选择自行清除数据，程序管理器包含一个选择允许用户清除数据。当为true时，用户可自己清理用户数据，反之亦然 android:allowTaskReparenting(‘true’ or ‘false’)默认值为false。是否允许activity更换从属的任务。当该Task下一次被带到前面时，应用程序定义的Activity是否可以从启动它们的Task移动到有相同affinity的Task，比如从短信息任务切换到浏览器任务。Activity可以设置自己的allowTaskReparenting`属性来覆盖Application节点下的这个属性。 android:backupAgent此属性没有默认值。实现应用backup代理的类名，它是BackupAgent的一个子类。这个属性值应该是一个完整的类名，如com.project.BackupAgent.。如果类名的第一个字母是”.”，它会附加到mainfest元素指定的包名之后。 android:backupInForeground默认为false。一个应用即使在前台状态下也可以执行自动备份。当应用正在自动备份时，系统可能会停止应用，因此要谨慎的使用该属性。该属性设置为true会影响到处于激活状态下的应用的行为。 android:banner没有默认值。一个drawable资源，用来提供一个扩展的图形banner。使用application标签为应用所有的Activity提供一个默认的banner，或者使用activity标签为一个指定的Activity设置banner。在Android TV的home页，系统使用banner来表示一个应用。由于banner仅仅在home页显示，当一个应用中有处理CATEGORY_LEANBACK_LAUNCHER这个intent的Activity时，才能指定该属性。这个属性必须设置一个包含图片的drawable资源的引用(例如”@drawable/banner”)。 android:debuggable默认为false。这个从字面上就可以看出是什么作用的，当设置为true时，表明该APP在手机上可以被调试。在false的情况下调试该APP，就会报以下错误：Device XXX requires that applications explicitely declare themselves as debuggable in their manifest.Application XXX does not have the attribute ‘debuggable’ set to TRUE in its manifest and cannot be debugged. android:description关于应用的用户可读的文字，比label属性更长、更具描述性。这个属性必须设置为一个字符串资源的引用。不像label属性，它不能是一个raw字符串。没有默认值 android:enabled默认为true。Android系统是否能够实例化该应用程序的组件-true表示可以，false表示不可以。如果为true，每个组件的enabled属性决定那个组件是否可以被 enabled。如果为false，它覆盖组件指定的值，即所有组件都是disabled。 android:extractNativeLibs默认值为true。包安装器能否从apk中抽取本地库到文件系统。如果设置为false，你的本地库必须页对其并且在apk中以未压缩的方式存储。链接器在运行时从apk中直接加载库不会导致代码改动。 android:fullBackupContent该属性指向一个xml文件，这个文件包含了自动备份时全部的备份规则。这些规则决定了哪些文件会被备份。该属性为可选的。如果没设置，默认情况下，自动备份会备份应用的大部分的文件。 android:fullBackupOnly=[“true” | “false”]默认值是false。当设备可用时是否使用自动备份。如果设置为true，当应用安装到运行Android 6.0及其更高版本的的设备上时，会运行自动备份，在低版本的设备上，应用将忽略这个属性并执行key/value方式的备份。 android:hasCode(‘true’ or ‘false’)默认为true。表示此APP是否包含任何的代码。若为false，则系统在运行组件时，不会去尝试加载任何的APP代码一个应用程序自身不会含有任何的代码，除非内置组件类，比如Activity类，此类使用了AliasActivity类，当然这是个罕见的现象(在Android2.3可以用标准C来开发应用程序，可在androidManifest.xml中将此属性设置为false,因为这个APP本身已经不含有任何的JAVA代码了) android:hardwareAccelerated=[“true” | “false”]如果你设置了minSdkVersion或targetSdkVersion 为14或更高，默认是启用；否则默认不启用。应用中所有的Activity和View是否启用硬件加速渲染-true表示启用，false表示不启用。从 Android 3.0 (API level 11)开始，应用可使用支持硬件加速的OpenGL 渲染，用来提升许多通用的2D图形操作性能。当硬件加速渲染打开时，Canvas, Paint, Xfermode, ColorFilter, Shader, 和 Camera中的大部分操作都会被加速。这会使得动画更流畅、滑动更流畅，提升整体的响应性，甚至应用不必显式的使用framework的 OpenGL库。需要注意的是，不是全部的OpenGL 2D操作都会被加速。如果你打开了硬件加速渲染，请测试你的应用以确保使用渲染的过程中不会出错。 android:icon没有默认图标。一个作为整体应用的图标，就是声明整个APP的图标(在桌面的启动图标,图片一般都放在drawable文件夹下)，并且是应用的每个组件的默认图标。 &lt; activity&gt;, &lt; activity-alias&gt;, &lt; service&gt;, &lt; receiver&gt;和 &lt; provider&gt;都可以有各自的图标。这个属性必须被设置为一个包含图片的drawable资源文件的引用（比如”@drawable/icon”）。 android:isGame=[“true” | “false”]应用是否为游戏。系统可能把应用根据游戏分组或把它们与其他的应用分开来显示。默认为false。 android:killAfterRestore默认值为true。当应用在全系统层面的恢复操作时，应用的设置被恢复后，应用应当终止运行。单个包的恢复操作不会导致应用关闭。全系统的恢复操作一般来说只会发生一次，即在手机第一次启动时。第三方的应用一般没必要使用这个属性。意味着当应用在全系统的恢复操作中处理完自己的数据后，将会停止运行。 android:largeHeap=[“true” | “false”]你的应用进程是否通过一个largeDalvik heap 被创建。这个属性适用于所有的为应用创建的进程。它仅适用于被加载到进程的第一个应用；如果你使用shared user id来允许多个应用在同一个进程中，它们都必需一致的使用这个选项，否则可能出现不可预知的结果。大部分app都不应使用这个属性，而应该把焦点放在如何减少整体的内存使用来提示性能。启用此功能也不能保证可用内存的固定增加，因为一些设备被全部可用内存限制了。可使用ActivityManager.getMemoryClass() or ActivityManager.getLargeMemoryClass()在运行时获取可用的内存大小。 android:label应用的标签名(应用名称)。把应用作为整体的用户可读标签，也是应用中各个组件的默认标签。 &lt; activity&gt;, &lt; activity-alias&gt;, &lt; service&gt;, &lt; receiver&gt;, &lt; provider&gt; 都可以设置各自的标签。标签应设置为一个字符串资源的引用，以便可以像用户界面中的其他字符串一样进行本地化。为了方便，在开发应用时可以设置为原始字符串。 android:logo=”drawable resource”应用作为一个整体的logo，也是所有Activity的默认logo。这个属性必须被设置为一个包含图片的drawable资源的引用（比如@drawable/logo）。没有默认logo。默认情况下，使用在ActionBar中使用icon，如果同时也设置了logo属性，ActionBar上将使用logo。logo应比icon远，但不应包括不必要的文本。 只有在以用户认可的传统格式表示您的品牌时才应使用logo。 logo代表预期的使用者品牌，而应用程序的的icon是符合启动器图示方形要求的修改版本。 android:manageSpaceActivity一个Activity子类的全限定名，系统可以启动它来让用户管理设备上应用的内存使用情况。这个Activity也必须使用&lt; activity&gt; 元素来声明。 android:name为应用程序所实现的Application子类的全名。当应用程序进程开始时，该类在所有应用程序组件之前被实例化。若该类(比方androidMain类)是在声明的package下，则可以直接声明android:name=”androidMain”,但此类是在package下面的子包的话，就必须声明为全路径或android:name=”package名称.子包名成.androidMain” android:permission为了跟应用交互，客户端必须拥有的权限。这个属性是适用于应用中所有组件设置权限的一个方便的方法。每个组件可设置各自的permission属性来覆盖application中的这个属性。 android:presistent默认值是false。该应用程序是否应该在任何时候都保持运行状态,默认为false。因为应用程序通常不应该设置本标识，持续模式仅仅应该设置给某些系统应用程序才是有意义的。 android:process应用程序运行的进程名，它的默认值为元素里设置的包名，当然每个组件都可以通过设置该属性来覆盖默认值。如果你想两个应用程序共用一个进程的话，你可以设置他们的android:process相同，但前提条件是他们共享一个用户ID及被赋予了相同证书的时候 android:restoreAnyVersion此属性的默认值为false。用来表明应用是否准备尝试恢复所有的备份，即使该备份是由比当前在设备上安装的应用程序的更新版本存储的。 将此属性设置为true将允许备份管理器尝试恢复，即使版本不匹配表明数据不兼容。 使用时要小心！。 android:requiredAccountType=”string”指定应用程序为了运行所需的帐户类型。 如果您的应用需要帐户，则此属性的值必须与您的应用使用的帐户验证器类型（由AuthenticatorDescription定义）（如“com.google”）相对应。默认值为null，表示应用程序可以在没有任何帐户的情况下工作。由于受限个人资料目前无法添加帐户，因此指定此属性会使您的应用无法从受限个人资料中获取，除非您也声明了android：restrictedAccountType具有相同的值。警告：如果帐户数据可能显示个人身份信息，请务必声明此属性并将android：restrictedAccountType设置为null，以便受限配置文件无法使用您的应用访问属于所有者用户的个人信息。此属性在API级别18中添加。 android:resizeableActivity=[“true” | “false”]指定应用是否支持多窗口显示。你可以在 &lt; activity&gt; 或 &lt; application&gt;元素中设置该属性。如果设置为true，用户可在分屏和freeform 模式下启动Activity。如果设置为false，Activity将不支持多窗口模式。如果这个值为false，并且用户尝试在多窗口模式下启动Activity，Activity将会全屏显示。如果你的应用的 targets API 是24或者更高，如果你不指定这个属性，默认值是true。这个属性是在 API level 24新增的。 android:restrictedAccountType=”string”指定此应用程序所需的帐户类型，并指示允许受限制的配置文件访问属于所有者用户的此类帐户。 如果您的应用需要帐户，且受限个人资料可以访问主要用户的帐户，则此属性的值必须与您的应用所使用的帐户验证器类型（由AuthenticatorDescription定义）（如“com.google”）相对应。默认值为null，表示应用程序可以在没有任何帐户的情况下工作。警告：指定此属性允许受限配置文件使用属于所有者用户的帐户使用您的应用程序，这可能会泄露个人身份信息。 如果帐户可能显示个人详细信息，您不应使用此属性，而应声明android：requiredAccountType属性，使您的应用程序不能使用限制的配置文件。此属性在API级别18中添加。 android:supportsRtl=[“true” | “false”]默认值是false。声明你的应用是否支持从右向左布局。如果设置为true并且targetSdkVersion 大于等于17，多个RTL相关的API将被激活，被系统使用，从而使得你的app能够显示从右向左的布局。如果设置为false或targetSdkVersion小于17，RTL相关的API将无效或者被忽略，你的app将无视布局方向，始终是从左向右的方向。在API level 17中引入的这个属性。 android:taskAffinity拥有相同的affinity的Activity理论上属于相同的Task，应用程序默认的affinity的名字是元素中设定的package名（manifest中通过 &lt; manifest&gt;元素设置的包名）。除了那些设置了不同affinity属性的Activity android:testOnly=[“true” | “false”]表示一个应用是否仅仅用于测试。例如，它可能暴露它自己的功能或外部数据，这些可能导致一个安全漏洞，但对调试来说有用。这类应用仅仅可以通过adb命令安装。 android:theme是一个资源的风格，它定义了一个默认的主题风格给所有的activity，可以后续在activity标签层单独覆盖此Theme。 android:uiOptions=[“none” | “splitActionBarWhenNarrow”]Activity UI的额外选项，必须是下列值中的一个。 “none”： 没有额外的UI选项，这是默认值。 “splitActionBarWhenNarrow”：在屏幕底部添加一个条形，以在水平空间受限时（例如在手机上的纵向模式下）在应用栏（也称为操作栏）中显示操作项目。 而不是显示在屏幕顶部的应用栏中的少量操作项，应用栏分割为顶部导航部分和操作项的底部栏。 这确保了不仅为操作项目而且在顶部的导航和标题元素提供合理的空间量。 菜单项不分割在两个条上; 他们总是出现在一起。该属性是在 API level 14中新增的。 android:usesCleartextTraffic=[“true” | “false”]默认值为true。指示应用程序是否要使用明文网络流量，例如明文HTTP。当属性设置为“false”时，平台组件（例如，HTTP和FTP堆栈，DownloadManager，MediaPlayer）将拒绝应用程序使用明文流量的请求。强烈鼓励第三方图书馆也遵守此设置。避免明文流量的关键原因是缺乏保密性，真实性和防止篡改的保护：网络攻击者可以窃听传输的数据，并且还可以在不检测的情况下对其进行修改。这个标志是最好的努力的基础上，因为它是不可能防止来自Android应用程序的所有明文流量给定的访问级别提供给他们。例如，没有期望Socket API将尊重此标志，因为它不能确定其流量是否为明文。然而，来自应用程序的大多数网络流量由更高级网络堆栈/组件处理，可以通过从ApplicationInfo.flags或NetworkSecurityPolicy.isCleartextTrafficPermitted（）读取该标志来处理该标志。注意：WebView不遵守此标志。在应用程序开发期间，StrictMode可用于标识来自应用程序的任何明文流量：请参阅StrictMode.VmPolicy.Builder.detectCleartextNetwork（）。此属性是在API级别23中添加的。如果存在Android网络安全配置，此标记在Android 7.0（API级别24）及以上版本中将被忽略。 android:vmSafeMode=[“true” | “false”]表示应用让虚拟机运行在安全模式。默认值为false。这个属性在 API level 8 中引入，true表示禁用DalvikJIT编译器。在API level 22 中有改动，true表示禁用ART AOT编译器","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"android-guides","date":"2017-02-13T08:33:02.000Z","path":"2017/02/13/android/android-guides/","text":"基本用法Button对于Button上的文本，系统会对Button中的所有英文字母自动进行大写转换，如果这不是你想要的效果，可以使用如下配置来禁用这一默认特性1234567// android:textAllCaps=\"false\"&lt;Button android:id=\"@+id/button\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button\" android:textAllCaps=\"false\" /&gt; ProgressBar12345// style 默认圆形style=\"?android:attr/progressBarStyleLarge\"style=\"?android:attr/progressBarStyleSmall\"style=\"?android:attr/progressBarStyleSmallTitle\"style=\"?android:attr/progressBarStyleHorizonal\" //水平 ProgressDialogBroadcast 不允许开启线程，不能做耗时操作(10秒左右) 注册：registerReceiver(本地广播需要使用LocalBroadcastManager) 取消注册：unregisterReceiver 广播类型： 无序广播(默认)：所有广播接收器都可以接受到。调用sendBroadcast()发送广播 有序广播：优先级比较高的广播接收器(android:priority)可以先收到广播，使用abortBroadcast可以截断广播。调用sendOrderedBroadcast发送广播 123&lt;intent-filter android:priority=\"100\"&gt; ......&lt;/intent-filter&gt; 本地广播：发出的广播只能本程序才能收到。调用LocalBroadcastManager的sendBroadcast发送广播 ACTION12android.net.conn.CONNECTIVITY_CHANGE // 网络状态发生变化 权限：ACCESS_NETWORK_STATEandroid.intent.action.BOOT_COMPLETED // 开机广播 权限：RECEIVE_BOOT_COMPLETED Shader权限 可以使用RxPermissions简化权限操作 下表列出了Android中所有的危险权限，一共是9组24个权限。 权限组名 权限名 CALENDAR READ_CALENDARWRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTS LOCATION ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATECALL_PHONEREAD_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMSRECCEIVE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVE_MMS STORAGE READ_EXTERNAL_STORAGEWRITE_EXTERNAL_STORAGE 密度 建议尺寸 mipmap-mdpi 48 * 48 mipmap-hdpi 72 * 72 mipmap-xhdpi 96 * 96 mipmap-xxhdpi 144 * 144 mipmap-xxxhdpi 192 * 192 float xdpi = getResources().getDisplayMetrics().xdpi;float ydpi = getResources().getDisplayMetrics().ydpi; dpi范围 密度 0dpi ~ 120dpi ldpi 120dpi ~ 160dpi mdpi 160dpi ~ 240dpi hdpi 240dpi ~ 320dpi xhdpi 320dpi ~ 480dpi xxhdpi 480dpi ~ 640dpi xxxhdpi 子线程更新UI 因为在 OnCreate 的 时候，View 是还没有被 ViewRootImpl加载到 Window，所以子线程修改 View 的代码没有经过 ViewRootImpl 的检测。贯穿全文，就告诉了大家在 onResum 之前在子线程可以修改 UI，具体原因没讲清楚。可以讲讲 contentView 是怎样被ViewRootImplement 加载到 Window。Window、Activity、View、ViewRootImpl 之间的关系？ 如果你的app必须要使用本地lib引入v4库，那么就排除开源库的v4包 123compile(&apos;com.facebook.fresco:fresco:0.10.0&apos;) &#123; exclude module: &apos;support-v4&apos;&#125; 如果是源码形式引入的开源库 123compile (project(&apos;:thirdpart:RecyclerViewAdapterLibrary&apos;))&#123; exclude group: &apos;com.android.support&apos; &#125; exclude group:表示只要包含com.android.support的都排除 123api(&quot;com.afollestad.material-dialogs:core:0.9.5.0&quot;) &#123; exclude group: &apos;com.android.support&apos;&#125; module：删排除group中的指定module 1234api(&quot;com.afollestad.material-dialogs:core:0.9.5.0&quot;) &#123; exclude group: &apos;com.android.support&apos;, module: &apos;support-v13&apos; exclude group: &apos;com.android.support&apos;, module: &apos;support-vector-drawable&apos; &#125;","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"mac-os-tips","date":"2017-02-10T07:28:39.000Z","path":"2017/02/10/study/mac-os-tips/","text":"Tips有时候，我们安装程序时，会提示文件已损坏，需要打开安全性与隐私中的任何来源选项 1sudo spctl --master-disable 显示文件隐藏文件夹 1command + shift + .","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"refactor","date":"2017-02-09T08:53:10.000Z","path":"2017/02/09/refactor/refactor/","text":"重构 如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后现添加特性 重构前，先检查自己是否有一套可靠的测试机制，这些测试必须有自我检验能力 重构技术就是以微小的步伐修改程序，如果你犯下错误，很容易使可发现它。 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。 当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。 重构原则何为重构 重构(名词)：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本 重构(动词)：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。 为何重构 重构改进软件设计 重构使软件更容易理解 重构帮助找到BUG 重构提高编程速度 何时重构三次法则（事不过三，三则重构） 添加功能时重构 修补错误时重构 复审代码时重构 代码的坏味道 Duplicated Code(重复代码) Long Method(过长函数) Large Class(过大的类) Long Parameter List(过长参数列) Divergent Change(发散式变化) （如果某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了） Shotgun Surgery(霰弹式修改) （Shotgun Surgery类亿Divergent Change，但恰恰相反。如果每遇到某种变化，你都必须在许多不同的类内做许多小修改，你所面临的坏味道就是Shotgun Surgery） Feature Envy(依恋情结) （函数对某个类的兴趣高过对自己所处类的兴趣） Data Clumps(数据泥团) （两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。） Primitive Obsession(基本类型偏执) （对象技术的新手通常不愿意在小任务上运用小对象—像是结合数值和币种的money类、由一个超始值和一个结束值组成的range类、电话号码或邮政编码） Switch Statements(switch惊悚现身) （你常会发现同样的switch语句散布于不同地点。如果要为它添加一个新的case子句，就必须找到所有switch语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。） Parallel Inheritance Hierarchies(平行继承体系) （Parallel Inheritance Hierarchies其实是Shotgun Surgery的特殊情况。在这种情况下，每当你为某个类增加一个子类，必须也为另一相类增加一个子类。如果你发现某个继承体系的类名称前缀和别一个继承体系的类名称前缀完全相同，便是闻到了这种坏味道。） Lazy Class(冗赘类) （你所创建的每一个类，都得有人去理解它、维护它，这些工作都是要花钱的。如果一个类的所得不值其身价，它就应该消失。） Speculative Generality(夸夸其谈未来性) （企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。） Temporary Field(令人迷惑的暂时字段) （某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。） Message Chains(过度耦合的消息链) （向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求别一个对象……这就是消息链。采取这种方式，意味客户代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生变化，客户端就不得不做了相应修改。） Middle Man(中间人) （对象的基本特征之一就是封装—对外部世界隐藏其内部细节。封装往往伴随委托。但是人们可能过度运用委托。你也许会看到某个类接口有一关的函数都委托给其他类，这样就是过度运用。） Inappropriate Intimacy(狎昵关系) （有时你会看到两个类过于亲密，花费太多时间去探究彼此的private成分。对于这样过分狎昵的类必须拆散。） Alternative Classes with Different Interfaces(异曲同工的类) （两个函数做同一件事，却有着不同的签名） Incomplete Library Class(不完美的库类) Data Class(纯稚的数据类) （它们拥有一些字段，以及用于访问、读写这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其它类过分细琐地操控着。对于那些不该被其他类修改的字段。请提示get/set） Refused Bequest(被拒绝的遗赠) (子类应该继承超类的函数和数据。但有时子类不需要继承一些无关的数据。这样一来，超类就只持有所有子类共享的东西。—所有超类都应该是抽象的) Comments(过多的注释) ​ 构筑测试体系 确保所有测试都完全自动化，让它们检查自己的测试结果。 一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需要的时间。 频繁地运行测试。每次编译请把测试也考虑进去—每天至少执行每个测试一次。 每当你收到bug报告，请先写一个单元测试来暴露这个bug。 编写未臻完善的测试并实际运行，好过对完美测试的无尽等待。 考虑可能出错的边界条件，把测试火力集中在那儿。 当事情被认为应该会出错时，别忘了检查是否抛出了预期的异常。 不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数bug。 重构列表重构的基本技巧———小步前进，频繁测试","tags":[{"name":"read","slug":"read","permalink":"yzbzz.github.io/tags/read/"}]},{"title":"android-okhttp","date":"2017-02-06T08:14:28.000Z","path":"2017/02/06/android/android-okhttp/","text":"概述 OKhttp3是一个高效的http&amp;http/2的客户端，用于android和java，支持同步和异步请求。 OKhttp3是开源界著名的Square公司的大作，大神JakeWharton的公司。Google已把Android的网络请求替换为Okhttp的实现 OKhttp3有以下优点： 支持请求相同host的所有请求，共享socket 连接池可以减少请求延迟(如果HTTP / 2不可使用)。 透明的GZIP压缩 响应缓存避免了完全重复的网络请求 socket自动选择最好路线，并支持自动重连 …… 支持版本：Android 2.3及以上，java1.7及以上 引用 注:okhttp内部依赖okio，同时导入okio： Grade 12compile ‘com.squareup.okhttp3:okhttp:3.3.1’compile ‘com.squareup.okio:okio:1.8.0’ 对于使用Eclipse的同学，可以去Square官网去下载相应的jar包 官网 okhttp okio 基本用法初始化一个client: 1private final OkHttpClient client = new OkHttpClient(); Get请求12345678910111213141516171819public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build(); // 同步 Response response = client.newCall(request).execute(); // 异步 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125; &#125;);&#125; Post请求1234567891011121314151617181920212223public void run() throws Exception &#123; Request.Builder builder = new Request.Builder() FormBody.Builder formEncodingBuilder = new FormBody.Builder(); formEncodingBuilder.add(key,value); RequestBody requestBody = formEncodingBuilder.build() builder.post(requestBody) builder.url(“http://publicobject.com/helloworld.txt”); Request request = builder.build(); // 同步 Response response = client.newCall(request).execute(); // 异步 client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125; &#125;); &#125; 添加Headers123456789101112131415public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"https://api.github.com/repos/square/okhttp/issues\") .header(\"User-Agent\", \"OkHttp Headers.java\") .addHeader(\"Accept\", \"application/json; q=0.5\") .addHeader(\"Accept\", \"application/vnd.github.v3+json\") .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); System.out.println(\"Server: \" + response.header(\"Server\")); System.out.println(\"Date: \" + response.header(\"Date\")); System.out.println(\"Vary: \" + response.headers(\"Vary\"));&#125; 上传文件12345678910111213public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(\"text/x-markdown; charset=utf-8\");public void run() throws Exception &#123; File file = new File(\"README.md\"); Request request = new Request.Builder() .url(\"https://api.github.com/markdown/raw\") .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful())&#123;&#125; System.out.println(response.body().string());&#125; 发送多个请求1234567891011121314151617181920private static final String IMGUR_CLIENT_ID = \"...\";private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(\"image/png\");public void run() throws Exception &#123; RequestBody requestBody = new MultipartBody.Builder() .setType(MultipartBody.FORM) .addFormDataPart(\"title\", \"Square Logo\") .addFormDataPart(\"image\", \"logo-square.png\", RequestBody.create(MEDIA_TYPE_PNG, new File(\"website/static/logo-square.png\"))) .build(); Request request = new Request.Builder() .header(\"Authorization\", \"Client-ID \" + IMGUR_CLIENT_ID) .url(\"https://api.imgur.com/3/image\") .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful())&#123;&#125;&#125; 用Gson解析Json Response1234567891011121314151617181920212223private final Gson gson = new Gson();public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"https://api.github.com/gists/c2a7c39532239ff261be\") .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(\"Unexpected code \" + response); Gist gist = gson.fromJson(response.body().charStream(), Gist.class); for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123; System.out.println(entry.getKey()); System.out.println(entry.getValue().content); &#125;&#125;static class Gist &#123; Map&lt;String, GistFile&gt; files;&#125;static class GistFile &#123; String content;&#125; 缓存12345678910111213private final OkHttpClient client;public CacheResponse(File cacheDirectory) throws Exception &#123; int cacheSize = 10 * 1024 * 1024; // 10 MiB Cache cache = new Cache(cacheDirectory, cacheSize); client = new OkHttpClient.Builder() .cache(cache) .build(); Request request = new Request.Builder() .url(\"http://publicobject.com/helloworld.txt\") .build(); Response response1 = client.newCall(request).execute();&#125; 取消一个请求12345678910private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"http://httpbin.org/delay/2\") .build(); final Call call = client.newCall(request); Response response = call.execute(); call.cancel();&#125; 设置超时1234567891011121314151617private final OkHttpClient client = new OkHttpClient();public ConfigureTimeouts() throws Exception &#123; client = new OkHttpClient.Builder() .connectTimeout(10, TimeUnit.SECONDS) .writeTimeout(10, TimeUnit.SECONDS) .readTimeout(30, TimeUnit.SECONDS) .build();&#125;public void run() throws Exception &#123; Request request = new Request.Builder() .url(\"http://httpbin.org/delay/2\") .build(); final Call call = client.newCall(request); Response response = call.execute();&#125; 自定义拦截器12345678910111213141516171819private final OkHttpClient client = new OkHttpClient();public void run() throws Exception &#123; client.networkInterceptors().add(new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request originalRequest = paramChain.request(); …… …… …… return paramChain.proceed(compressedRequest); &#125; &#125;); Request request = new Request.Builder() .url(\"http://httpbin.org/delay/2\") .build(); final Call call = client.newCall(request); Response response = call.execute();&#125;","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"js-blogs","date":"2017-01-10T08:33:54.000Z","path":"2017/01/10/blogs/js-blogs/","text":"微信小程序 加载 HTML 标签","tags":[{"name":"blog","slug":"blog","permalink":"yzbzz.github.io/tags/blog/"}]},{"title":"android-blogs","date":"2017-01-10T08:25:55.000Z","path":"2017/01/10/blogs/android-blogs/","text":"KotlinKotlin 资源大全 - 学 Kotlin 看这一篇教程就够了 【学习笔记】区别Kotlin中的object和companion object关键字 Blogs 安卓自定义View进阶 - 贝塞尔曲线 带你全面了解Glide 4的用法 从零开始的Android新项目2 - Gradle篇 贝塞尔风暴 － 超炫GABottleLoading效果 Android APK反编译就这么简单 详解（附图） APP淘宝，你为什么这么慢卡？ thinkSky1206 Android — Smooth shared transitions in all android versions – Medium nickbutcher/plaid: An Android app which provides design news &amp; inspiration as well as being an example of implementing material design. 五分钟带你看懂NestedScrolling嵌套滑动机制 Android 自定义View合集 不要在Android的Application对象中缓存数据! 这个项目碉堡了 Android7.0之拍照与图片裁剪适配 Android性能优化系列之App启动优化 Android application和activity标签详解 AndroidManifest.xml 最全详解 自定义View Layout过程 - 最易懂的自定义View原理系列 AndroidManifest–你真的理解了吗？ View 那些你应该知道却不一定知道的——View坐标分析汇总 召唤，光能使者–玩转PathMeasure Android Guides TabLayout http://www.jianshu.com/p/2b2bb6be83a8 Anima http://www.liujun.info/2017/04/25/Lottie库实现直播礼物动画/ 5分钟搞定开机引导界面 自定义Behavior的艺术探索-仿UC浏览器主页 http://ailoli.me/2017/05/03/Android粒子特效之-萤火虫飞舞效果/ Android轮播图控件的实现详解(附GitHub开源链接) CoordinatorLayout介绍 Android APK 瘦身 - JOOX Music项目实战 Android 翻页效果加苹果桌面应用抖动效果 简单高效的实现Android App全局字体替换 Android开发人员不得不收集的代码 可能是最火的开源项目 —— Java 篇 Aspect Oriented Programming in Android 史上最详细仿QQ消息拖拽粘性效果 高级UI特效仿直播点赞效果—一个优美炫酷的点赞动画 Debug 7.1.1源码一步步写Android换肤框架 MIUI 系统 BUG，Android 调用相机崩溃？将拍照适配方案进行到底！ http://zhengxiaoyong.me/categories/ 你最不想错过的 2017 早期 25 个 Android 开源库 Android开发：RecyclerView平滑流畅的滑动到指定位置 Android 项目总结(一)：弧形ViewPager 和弧形HeaderView 苹果核 - 一种动态为apk写入信息的方案 Android学习文档和工具 手把手教你写高质量Android技术博客，画图工具，录像工具，Markdown写法 仿淘宝、京东拖拽商品详情(可嵌套ViewPager、ListView、WebView、FragmentTabhost) 【开发利器】中国国内可用API合集 当你只有一个设备的时候，如何做好屏幕适配 Android 源码，在线阅读更方便！！！ Glide 这样用，更省内存！！！ View.post() 不靠谱的地方你知道吗？ 把倒计时做到极致 使用 Router 实现的模块化，如何优雅的回到主页面 Android：手把手教你构建 WebView 的缓存机制 &amp; 资源预加载方案 自定义view系列之——Android贝塞尔曲线–基础篇 一篇文章，学会Git和Gitflow工作流 Android 软键盘的显示和隐藏，这样操作就对了 Android 系统中，那些能大幅提高工作效率的 API 汇总（持续更新中…） Android 开发中，与屏幕有关的三个小众知识 图解ConcurrentHashMap AOP编程之AspectJ实战实现数据无痕埋点 2017下半年掘金日报优质文章合集：Android篇 堪比阿里插件的 Android Studio 插件集合(IDE通用)（下） 诡异的空指针 Android 开发，你遇上 Emoji 头疼吗? 如何避免使用onActivityResult，以提高代码可读性 分享两个提高效率的AndroidStudio小技巧 Android ValueAnimator时长错乱或者不起作用的解决方法以及问题分析 [译] 探索 Android Design Support Library v28 新增内容 AspectJ在Android中的应用 Android小技巧 提升开发效率 Android Studio使用技巧系列教程（三） RecycleView的拖动排序 彻底弄清support支持库，以及v4 v7重复依赖问题深究 贝塞尔曲线 [http://jcenter.bintray.com/ https://dl.google.com/dl/android/maven2/index.html 仿微信朋友圈，点击评论，生成自定义超链接，并处理 安卓 TextView 七宗罪","tags":[{"name":"blog","slug":"blog","permalink":"yzbzz.github.io/tags/blog/"}]},{"title":"blogs","date":"2017-01-10T08:12:44.000Z","path":"2017/01/10/blogs/blogs/","text":"简书 milter CSDN CGD精讲(Swift3) http://www.jianshu.com/p/929f8a56eef6 http://home.duiba.com.cn/docs.html gitbook转转换成pdf 英文 史上最详细的Hadoop环境搭建 Introduction 利用 Spring Boot 设计风格良好的Restful API及错误响应","tags":[{"name":"blog","slug":"blog","permalink":"yzbzz.github.io/tags/blog/"}]},{"title":"react-native-flex","date":"2016-08-29T07:18:42.000Z","path":"2016/08/29/fe/react-native-flex/","text":"使用Flexbox布局我们在React Native中使用flexbox规则来指定某个组件的子元素的布局。Flexbox可以在不同屏幕尺寸上提供一致的布局结构。 一般来说，使用flexDirection、alignItems、justifyContent三个样式属性就已经能满足大多数布局要求。 Flex Direction在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。 Justify Content在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：flex-start、center、flex-end、space-around以及space-between Align Items在组件的style中指定alignItems可以决定其子元素沿着次轴（与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：flex-start、center、flex-end以及stretch。 注意：要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸","tags":[{"name":"fe","slug":"fe","permalink":"yzbzz.github.io/tags/fe/"}]},{"title":"react-native-text","date":"2016-08-22T08:47:44.000Z","path":"2016/08/22/fe/react-native-text/","text":"Text一个用于显示文本的React组件 Text支持嵌套、样式和触摸事件 Props accessible bool When set to true, indicates that the view is an accessibility element. The default value for a Text element is true. See the Accessibility guide for more information.ellipsizeMode enum(‘head’, ‘middle’, ‘tail’, ‘clip’) This can be one of the following values: head - The line is displayed so that the end fits in the container and the missing text at the beginning of the line is indicated by an ellipsis glyph. e.g., “…wxyz”middle - The line is displayed so that the beginning and end fit in the container and the missing text in the middle is indicated by an ellipsis glyph. “ab…yz”tail - The line is displayed so that the beginning fits in the container and the missing text at the end of the line is indicated by an ellipsis glyph. e.g., “abcd…”clip - Lines are not drawn past the edge of the text container.The default is tail. numberOfLines must be set in conjunction with this prop. clip is working only for iOSnumberOfLines number Used to truncate the text with an ellipsis after computing the text layout, including line wrapping, such that the total number of lines does not exceed this number. This prop is commonly used with ellipsizeMode. onLayout function Invoked on mount and layout changes with {nativeEvent: {layout: {x, y, width, height}}} onLongPress function This function is called on long press. e.g., `onLongPress={this.increaseSize}&gt;`` onPress function This function is called on press. e.g., `onPress={() =&gt; console.log(‘1st’)}``","tags":[{"name":"fe","slug":"fe","permalink":"yzbzz.github.io/tags/fe/"}]},{"title":"react-native-view","date":"2016-08-22T08:22:47.000Z","path":"2016/08/22/fe/react-native-view/","text":"View最基本的构建UI视图的容器，View 支持flexbox、style、一些触摸事件和访问性控制，View直接映射到native视图，不管在什么平台，不管它是UIView，，android.view，等等… View设计成嵌套其它视图，可以有0到任何类型的children View的设计初衷是和StyleSheet搭配使用，这样可以使代码更清晰并且获得更高的性能。尽管内联样式也同样可以使用 合成触摸事件PropsstylebackfaceVisibility ReactPropTypes.oneOf([‘visible’, ‘hidden’])backgroundColor colorborderBottomColor colorborderBottomLeftRadius ReactPropTypes.numberborderBottomRightRadius ReactPropTypes.numberborderBottomWidth ReactPropTypes.numberborderColor colorborderLeftColor colorborderLeftWidth ReactPropTypes.numberborderRadius ReactPropTypes.numberborderRightColor colorborderRightWidth ReactPropTypes.numberborderStyle ReactPropTypes.oneOf([‘solid’, ‘dotted’, ‘dashed’])borderTopColor colorborderTopLeftRadius ReactPropTypes.numberborderTopRightRadius ReactPropTypes.numberborderTopWidth ReactPropTypes.numberborderWidth ReactPropTypes.numberopacity ReactPropTypes.numberoverflow ReactPropTypes.oneOf([‘visible’, ‘hidden’])","tags":[{"name":"fe","slug":"fe","permalink":"yzbzz.github.io/tags/fe/"}]},{"title":"hexo","date":"2016-08-22T08:11:51.000Z","path":"2016/08/22/study/hexo/","text":"Hexo简介 官网：https://hexo.io/zh-cn/ 主题：yilia MARKDOWN EDITOR: typora TIPS1npm install hexo-deployer-git --save 其它命令不确定，部署这个命令一定要用git bash，否则会提示 Permission denied (publickey). 推荐博客： http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html 最适合新手的 GitHub + Hexo 「大话」博客搭建教程 新手搭建博客过程 Hexo常用命令 安装Hexo sudo npm install -g hexo 初始化 hexo init 生成静态页面 hexo generate(hexo g也可以) 本地启动 hexo server 执行配置命令上传到github hexo deploy 新建文章 hexo new &#39;postName&#39; 新建页面 hexo new page &#39;pageName&#39; 查盾帮助 hexo help 查看Hexo的版本 hexo version 每次部署的步骤，可按以下三步来进行 hexo clean hexo g hexo d","tags":[{"name":"study","slug":"study","permalink":"yzbzz.github.io/tags/study/"}]},{"title":"swift-life-cycle","date":"2016-06-30T09:08:15.000Z","path":"2016/06/30/Swift/swift-life-cycle/","text":"IOS生命周期 IOS Android viewWillAppear onCreate viewDidAppear onResume viewWillDisapper onPause viewDidApper onStop","tags":[{"name":"ios","slug":"ios","permalink":"yzbzz.github.io/tags/ios/"}]},{"title":"swift-record","date":"2016-06-22T07:03:30.000Z","path":"2016/06/22/Swift/swift-record/","text":"extension声明一个扩展使用关键字extension 123extension SomeType&#123; //加到SomeType的新功能写到这里&#125; indirect使用indirect来标识一个枚举是可以递归调用的 required在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器，在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，这是为了保证继承链上子类的构造器也是必要构造器。在重写父类的必要构造器时，不需要添加override修饰符 mutating一般情况下，值类型的属性不能在它的实例方法中被修改，mutating使得方法可以从方法内部改变它的属性；并且它做的任何改变在方法结束时还会保留在原始结构中。方法还可以给它隐含的self属性赋值一个全新的实例，这个新实例在方法结束后将替换原来的实例。要使用mutating方法，将关键字mutating放到方法的func关键字之前就可以了 unowned使用unowned标识无主引用 weak使用weak标识弱引用 类型属性在结构体和枚举中可以使用static来修饰静态变量，在类中可以使用static和class来修饰，使用class修饰来允许子类重写父类的实现方法","tags":[{"name":"ios","slug":"ios","permalink":"yzbzz.github.io/tags/ios/"}]},{"title":"What's in iOS?","date":"2016-06-22T07:03:30.000Z","path":"2016/06/22/ios/ios-stanford/","text":"What’s is in iOS? UIKItbounds VS frame 在未设置bounds的情况下，bounds是相对于view自身坐标的，以view自身的左上角为原点(0,0)，如上图所示，不管怎么旋转view，bounds始终是一样的 https://www.cnblogs.com/ming1025/p/6125706.html","tags":[{"name":"ios","slug":"ios","permalink":"yzbzz.github.io/tags/ios/"},{"name":"stanford","slug":"stanford","permalink":"yzbzz.github.io/tags/stanford/"}]},{"title":"android-tips","date":"2016-05-31T13:53:23.000Z","path":"2016/05/31/android/android-tips/","text":"解决Kotlin项目Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull, parameter savedInstanceState 当我们自定义application并实现ActivityLifecycleCallbacks方法，这时候我们会重写onActivityCreated这个方法 使用kotlin转换java代码，会是下面这样 123override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle) &#123;&#125; 这个时候我们需要把savedInstanceState: Bundle改为savedInstanceState: Bundle?，就是在Bundle后面加个?号 123override fun onActivityCreated(activity: Activity, savedInstanceState: Bundle?) &#123; &#125; OK，又可以继续玩耍了 Android allowBackup敏感信息泄露的一些解决方案 直接在你的Android清单文件中设置android:allowBackup=”false”即可，如下： 123&lt;application android:name=\".app.App\" android:allowBackup=\"true\"&gt; 不在你的Android清单文件中设置android:allowBackup=”false”，允许执行备份，但是在你应用启动页进行逻辑判断是否进行重新登陆等，譬如查看设备唯一识别设备编号和备份前是否一致，不一致则直接跳转登陆页面的同时清空当前应用数据及缓存。 设置背景颜色偶现无效最近在开发中碰到了一个问题，在Android5.0以上的手机，对布局设置背景颜色 1android:background=\"@color/c_4897fa\" 会出现背景颜色偶现无效的问题，使用下面的方法解决 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;!-- 角度 --&gt; &lt;corners android:radius=\"1dp\" /&gt; &lt;!-- 填充色 --&gt; &lt;solid android:color=\"@color/c_4897fa\" /&gt;&lt;/shape&gt; 1android:background=\"@drawable/home_nearby_bg\" 先画一个shape，再设置给backgroud 清除Android WebView 缓存12345678910111213public static void clearWebCache(Context context) &#123; try &#123; CookieSyncManager.createInstance(context); CookieManager cm = CookieManager.getInstance(); cm.removeSessionCookie(); cm.removeAllCookie(); CookieSyncManager.getInstance().sync(); WebStorage.getInstance().deleteAllData(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 捕获全局异常使用Thread.UncaughtExceptionHandler捕获全局异常 启动LaunchIntent1234Intent i = getBaseContext().getPackageManager().getLaunchIntentForPackage(getBaseContext().getPackageName());i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);startActivity(i); Annotations1234567891011121314151617181920212223@CallSuper@StringRes@DrawableRes@CheckResult@NonNull@Nullable@AnimatorRes@AnimRes@AnyRes@AnyThread@ArrayRes@AttrRes@BinderThread@ColorRes@ColorInt@BoolRes@DimenRes@Dimension@IdRes@FloatRange@FractionRes@IntegerRes@XmlRes 关于Android7.0系统使用webview遇到的一个问题(二级跳转后界面空白 https://github.com/panyz/Blogs/blob/master/Android实战经验/关于Android7.0系统使用webview遇到的一个问题(二级跳转后界面空白).md RecyclerView去掉滚动条和滑动到边界阴影 123456&lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rv_search_one\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:overScrollMode=\"never\" android:scrollbars=\"none\" /&gt; 设置屏幕常亮 12345678910@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);&#125; 使用PhotoView+Viewpager崩溃问题 java.lang.IllegalArgumentException: pointerIndex out of range 123456789101112131415161718192021222324252627282930// 自定义一个Viewpager，重写onInterceptTouchEvent函数，在里面捕获IllegalArgumentExceptionpublic class PhotoViewPager extends android.support.v4.view.ViewPager &#123; public PhotoViewPager(Context context) &#123; super(context); &#125; public PhotoViewPager(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; try &#123; return super.onTouchEvent(ev); &#125; catch (IllegalArgumentException ex) &#123; ex.printStackTrace(); &#125; return false; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; try &#123; return super.onInterceptTouchEvent(ev); &#125; catch (IllegalArgumentException ex) &#123; ex.printStackTrace(); &#125; return false; &#125;&#125; WebView自适应高度 123456789101112131415161718192021private void setupWebView() &#123; webView.getSettings().setJavaScriptEnabled(true); webView.setWebViewClient(new WebViewClient() &#123; @Override public void onPageFinished(WebView view, String url) &#123; webView.loadUrl(\"javascript:MyApp.resize(document.body.getBoundingClientRect().height)\"); super.onPageFinished(view, url); &#125; &#125;); webView.addJavascriptInterface(this, \"MyApp\");&#125;@JavascriptInterfacepublic void resize(final float height) &#123; MyActivity.this.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; webView.setLayoutParams(new LinearLayout.LayoutParams(getResources().getDisplayMetrics().widthPixels, (int) (height * getResources().getDisplayMetrics().density))); &#125; &#125;);&#125; http://www.bubuko.com/infodetail-1612451.html 通过resId获取属性名 例：R.id.tv_hello = 0x7f080007 当我们调用view的getId()时，我们能获取到0x7f080007，但有时我们需要获取到tv_hello这个属性名，可以使用下面的方法 1String name = getResources().getResourceEntryName(id); 使用AspectJ配置 使用网上的配置，在gradle版本为2.2.3时，不会出现问题，当切换到2.3.3时，会报 No such property: project for class: com.android.build.gradle.LibraryPlugin， 修复办法：不使用 LibraryPlugin 直接使用 project 1234567891011121314151617181920212223242526272829303132333435android.libraryVariants.all &#123; variant -&gt;// LibraryPlugin plugin = project.plugins.getPlugin(LibraryPlugin) JavaCompile javaCompile = variant.javaCompile javaCompile.doLast &#123; String[] args = [\"-showWeaveInfo\", \"-1.5\", \"-inpath\", javaCompile.destinationDir.toString(), \"-aspectpath\", javaCompile.classpath.asPath, \"-d\", javaCompile.destinationDir.toString(), \"-classpath\", javaCompile.classpath.asPath, \"-bootclasspath\", project.android.bootClasspath.join( File.pathSeparator)] MessageHandler handler = new MessageHandler(true); new Main().run(args, handler) def log = project.logger for (IMessage message : handler.getMessages(null, true)) &#123; switch (message.getKind()) &#123; case IMessage.ABORT: case IMessage.ERROR: case IMessage.FAIL: log.error message.message, message.thrown break; case IMessage.WARNING: case IMessage.INFO: log.info message.message, message.thrown break; case IMessage.DEBUG: log.debug message.message, message.thrown break; &#125; &#125; &#125;&#125; 解决支持库版本兼容问题： (all com.android.support libraries must use the exact same version specification) 去改第三方库所用的支持库版本比较麻烦，如果用的库很多的话工作量很大。这个时候我们可以考虑强制让所有模块都用相同的支持库版本。 在app build.gradle中添加： 12345678910configurations.all &#123; resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt; def requested = details.requested if (requested.group == 'com.android.support') &#123; if (!requested.name.startsWith(\"multidex\")) &#123; details.useVersion '25.3.1' &#125; &#125; &#125;&#125; 其中，25.3.1就是你要使用的支持库版本号，你可以根据需要改成其它的。 error: style attribute ‘@android:attr/windowEnterAnimation’ not found. 在Project/gradle.properties中添加 android.enableAapt2=false 解决Google Pixel Download Manager不在通知栏显示进度的BUG 123DownloadManager.Request request = new DownloadManager.Request(Download_Uri);// 添加下面这行request.setAllowedOverRoaming(false); 解决Error:Some file crunching failed, see logs for details 1234567891011android &#123; compileSdkVersion 25 buildToolsVersion '25.0.3' useLibrary 'org.apache.http.legacy' aaptOptions &#123; cruncherEnabled = false useNewCruncher = false &#125;&#125; 添加aaptOptions一栏 解决viewpager滑动不流畅的问题 12345678910111213141516171819202122232425262728293031public class customViewpagerView extends ViewPager &#123; private int preX=0; public customViewpagerView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public customViewpagerView(Context context) &#123; super(context); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent even) &#123; if(even.getAction()==MotionEvent.ACTION_DOWN) &#123; preX=(int) even.getX(); &#125;else &#123; if(Math.abs((int)even.getX()-preX)&gt;10) &#123; return true; &#125;else &#123; preX=(int) even.getX(); &#125; &#125; return super.onInterceptTouchEvent(even); &#125; &#125; 解决设置控件Alpha透明引发的问题12findViewById(R.id.login_whitebg)).getBackground().mutate().setAlpha(204);// https://www.jianshu.com/p/4d89fe683664","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"正则表达式","date":"2016-05-23T13:36:57.000Z","path":"2016/05/23/fe/regular-expression/","text":"概述 熟练地掌握正则表达式，能够使你的开发效率得到极大的提升。 下面来梳理了一下常用的正则表达式 校验密码强度 密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间 1^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 校验中文 字符串仅能是中文。 1^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 由数字、26个英文字母或下划线组成的字符串 1^\\\\w+$ 校验E-Mail地址 同密码一样，下面是E-mail地址合规性的正则检查语句。 1[\\\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+(?:\\\\.[\\\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])? 校验身份证号码 下面是身份证号码的正则校验。15或18位。 15位 1^[1-9]\\\\d&#123;7&#125;((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d&#123;3&#125;$ 18位 1^[1-9]\\\\d&#123;5&#125;[1-9]\\\\d&#123;3&#125;((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d&#123;3&#125;([0-9]|X)$ 校验日期 “yyyy-mm-dd”格式的日期校验，已考虑平闰年。 1^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 校验金额 金额校验，精确到2位小数 1^[0-9]+(.[0-9]&#123;2&#125;)?$ 校验手机号 下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） 1^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d&#123;8&#125;$ 提取URL链接 下面的这个表达式可以筛选出一段文本中的URL 1^(f|ht)&#123;1&#125;(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)?","tags":[{"name":"fe","slug":"fe","permalink":"yzbzz.github.io/tags/fe/"}]},{"title":"10个惊艳的Swift单行代码","date":"2016-05-22T10:59:51.000Z","path":"2016/05/22/Swift/swift-skill/","text":"概述 摘至：10 Swift One Liners To Impress Your Friends 数组中的每个元素乘以2 1(1...1024).map&#123; $0 * 2 &#125; 数组中的元素求和 1(1...1024).reduce(0, combine: +) 验证在字符串是否存在指定单词 使用filter 12345678let words = [\"Swift\",\"iOS\",\"cocoa\",\"OSX\",\"tvOS\"]let tweet = \"This is an example tweet larking about Swift\"let valid = !words.filter(&#123;tweet.containsString($0)&#125;).isEmptyprint(valid) // true// orwords.contains(tweet.containsString)// ortweet.characters.split(\" \").lazy.map(String.init).contains(Set(words).contains) 读取文件 12345678let path = NSBundle.mainBundle().pathForResource(\"test\", ofType: \"txt\")let lines = try? String(contentsOfFile: path!).characters.split&#123;$0 == \"\\n\"&#125;.map(String.init)if let lines=lines &#123; lines[0] // O! for a Muse of fire, that would ascend lines[1] // The brightest heaven of invention! lines[2] // A kingdom for a stage, princes to act lines[3] // And monarchs to behold the swelling scene.&#125; 祝你生日快乐! 12let name = \"uraimo\"(1...4).forEach&#123;print(\"Happy Birthday \" + (($0 == 3) ? \"dear \\(name)\":\"to You\"))&#125; 过滤数组中的数字 12345var part3 = [82, 58, 76, 49, 88, 90].reduce( ([],[]), combine: &#123; (a:([Int],[Int]),n:Int) -&gt; ([Int],[Int]) in (n&lt;60) ? (a.0+[n],a.1) : (a.0,a.1+[n])&#125;)print(part3) // ([58, 49], [82, 76, 88, 90]) 获取并解析XML Web服务 123456789let xmlDoc = try? AEXMLDocument(xmlData: NSData(contentsOfURL: NSURL(string:\"https://www.ibiblio.org/xml/examples/shakespeare/hen_v.xml\")!)!)if let xmlDoc=xmlDoc &#123; var prologue = xmlDoc.root.children[6][\"PROLOGUE\"][\"SPEECH\"] prologue.children[1].stringValue // Now all the youth of England are on fire, prologue.children[2].stringValue // And silken dalliance in the wardrobe lies: prologue.children[3].stringValue // Now thrive the armourers, and honour's thought prologue.children[4].stringValue // Reigns solely in the breast of every man: prologue.children[5].stringValue // They sell the pasture now to buy the horse,&#125; 在数组中查找最小（或最大）值 12345678//Find the minimum of an array of Ints[10,-22,753,55,137,-1,-279,1034,77].sort().first[10,-22,753,55,137,-1,-279,1034,77].reduce(Int.max, combine: min)[10,-22,753,55,137,-1,-279,1034,77].minElement()//Find the maximum of an array of Ints[10,-22,753,55,137,-1,-279,1034,77].sort().last[10,-22,753,55,137,-1,-279,1034,77].reduce(Int.min, combine: max)[10,-22,753,55,137,-1,-279,1034,77].maxElement() 并行处理 某些语言允许用一种简单和透明的方式启用数组对功能，例如map和flatMap的并行处理，以加 快顺序和独立操作的执行。 此功能Swift中还不可用，但可以使用GCD构建：http://moreindirection.blogspot.it/2015/07/gcd-and-parallel-collections-in-swift.html 埃拉托斯特尼筛法 埃拉托斯特尼筛法用于查找所有的素数直到给定的上限n。 从小于n的所有整数序列开始，算法删除所有整数的倍数，直到只剩下素数。并且为了加快执行速 度，我们实际上并不需要检查每个整数的倍数，我们止步于n的平方根就可以了。 根据这一定义首次执行可能是这样的： 12345var n = 50var primes = Set(2...n)(2...Int(sqrt(Double(n)))).forEach&#123;primes.subtractInPlace((2*$0).stride(through:n, by:$0))&#125;primes.sort() 我们使用外部范围来迭代我们要检查的整数，并且对于每一个整数我们使用 stride(through:Int by:Int)计算出数字的倍数的序列。那些序列然后从Set中减去，Set用所有从2到n的整数初始化。 但正如你所看到的，为了实际移除倍数，我们使用外部可变Set，导致了附带后果。 为了消除附带后果，正如我们通常应该做的那样，我们会先计算所有序列，用倍数的单一数组来 flatMap它们，并从初始Set中删除这些整数。 12345var sameprimes = Set(2...n)sameprimes.subtractInPlace((2...Int(sqrt(Double(n)))) .flatMap&#123; (2*$0).stride(through:n, by:$0)&#125;)sameprimes.sort() 方式更清洁，使用flatMap的一个很好的例子以生成扁平化的嵌套数组。 元组交换 1234var a=1, b=2(a, b) = (b, a)print(a) // 2print(b) // 1","tags":[{"name":"ios","slug":"ios","permalink":"yzbzz.github.io/tags/ios/"}]},{"title":"android-context","date":"2016-05-21T10:53:02.000Z","path":"2016/05/21/android/android-context/","text":"Context的能力Context能做的通用操作决定于这个context最初来源于哪里。下表所列的是，在应用中常见的会收到context对象，以及对应的每种情况，它可以用于哪些地方： Application Activity Service ContentProvider BroadcaseReceiver 显示Dialog NO YEA NO NO NO 启动Activity NO1 YES NO1 NO1 NO1 Layout Inflation NO2 YES NO2 NO2 NO2 启动Service YES YES YES YES YES 绑定Service YES YES YES YES NO 发送Broadcast YES YES YES YES YES 注册BroadcastReceiver YES YES YES YES NO3 加载Resource YES YES YES YES YES 需要注意的是： NO1：表示这些类的确可以开始一个Activity，但是它需要创建一个新的task。这可能会满足一些特定的需求，但是在你的应用中会创建一个不标准的回退栈（back stack），这通常是不推荐的或者不是最好的实践 NO2：表示这些类去layout inflate是合法的，但是会使用系统默认的主题，如果你自定义了某些样式，可能不会被使用 NO3：表示在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。 总结对于UI相关的方法，都不建议或者不可使用Application，都应该使用Activity作为Context来处理。另外需要注意Context引用的持有，防止内存泄漏。","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"Swift初见","date":"2016-05-21T09:48:59.000Z","path":"2016/05/21/Swift/swift-basic/","text":"概述 本文摘至：《The Swift Programming Language》 Swift是一种新的编程语言，用于编写ios，OS X和watch OS应用程序。Swift结合了C和Objective-C的优点并且不受C兼容性的限制。Swift采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift是基于成熟而且倍受喜爱的Cocoa和Cocoa Touch框架，它的降临将重新定义软件开发。 使用Playground编写Swift，可以实现查看。打开Xcode，创建一个Playground文件(File –&gt; New –&gt; Playground)。 Tips: 把鼠标放在Playground的右边区域，会有个小眼睛的图标和一个小白圈，点击有惊喜 画正弦 1234var num: Doublefor i in 1...100 &#123; num = sin(Double(i) / 10)&#125; Swift 初见通常来说，编程语言教程中的第一个程序应该在屏幕上打印”Hello, world”。在Swift中，可以用一行代码实现。 1print(\"Hello, world!\") 不同于java等语言，swift并不需要在语句结尾强制加上一个分号;。如果一行写2个语句，需要加上分号; 1let explicitFloat: Float = 70; let explicitDouble: Double = 4 简单值使用let来声明常量，使用var来声明变量。一个常量的值，在编译的时候，并不需要有明确的值，但是你只能为它赋值一次。类似java的final修饰的变量 123var myVariable = 42myVariable = 50let myConstant = 42 你不用明确的声明类型，声明的同时赋值的话，编译器会自动推断类型。在上面的例子中，编译器推断出 myVariable是一个整数(integer)，因为它的初始值是整数。 如果 初始值没有提供足够的信息(或者没有初始值)，那你需要在变量后面声明类型，用冒号分割。 1234let implicitInteger = 70let implicitDouble = 70.0let explicitDouble: Double = 70let explicitFloat: Float = 4 值永远不会被隐式转换成其他类型。如果你需要把一个值转换成其它类型，请显示转换。 123let label = \"The width is\"let width = 94let widthLabel = label + String(width) 有一种更简单的把值转换成字符串的方法：把值写到括号中，并且在括号之前写一个反斜杠。例如： 1234let apples = 3let oranges = 5let appleSummary = \"I have \\(apples) apples.\"let fruitSummary = \"I have \\(apples + oranges) pieces of fruit.\" 使用方括号[]来创建数组和字典，并使用下标或者键（key）来访问元素。最后一个元素后面允许有个逗号。 1234var shoppingList = [\"Catfish\", \"water\", \"tulips\", \"blue paint\"]shoppingList[1] = \"bottle of water\"var occupations = [\"Malcolm\": \"Captain\", \"Keylee\": \"Mechanic\",]occupations[\"Jayne\"] = \"Public Relations\" 要创建一个空数组或者字典，使用初始化语法。 12let emptyArray = [String]()let emptyDictionary = [String: Float]() 如果类型信息可以被推断出来，你可以用[]和[:]来创建空数组和空字典 — 就像你声明变量或者给函数传参数的时候一样。 12shoppingList = []occupations = [:] 控制流使用if和switch来进行条件操作，使用for-in、for、while和repeat-while来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。 12345678910let individualScores = [75, 43, 103, 87, 12]var teamScore = 0for score in individualScores &#123; if score &gt; 50 &#123; teamScore += 3 &#125; else &#123; teamScore += 1 &#125;&#125;print(teamScore) // 11 在if语句中，条件必须是一个布尔表达式 — 这意味着像if score { ... }这样的代码将报错，而不会隐形的与 0 做对比。 你可以一起使用if和let来处理缺失的情况。这些值可由可先值来代表。一个可选的值是一个具体的值或者是nil以表示值缺失。在类型后面加一个问号来标记这个变量的值是可选的。 12345678var optionalString: String? = \"Hello\"print(optionalString == nil)var optionalName: String? = \"John Appleseed\"var greeting = \"Hello!\"if let name = optionalName &#123; greeting = \"Hello, \\(name)\"&#125; if let name = optionalName 这句的意思是：如果optionalName不是nil，就把值赋给 name，条件判断为 true，进入 if 语句块；如果optionalName为nil，条件会判断为 false，不进入 if 语句块 switch支持任意类型的数据以及各种比较操作 — 不仅仅是整数以及测试相等。 123456789101112let vegetable = \"red pepper\"switch vegetable &#123; case \"celery\": print(\"Add some raisins and make ants on a log.\") case \"cucumber\", \"watercress\": print(\"That would make a good tea sandwich.\") case let x where x.hasSuffix(\"pepper\"): print(\"Is it a spicy \\(x)?\") default: print(\"Everything tastes good in soup.\")&#125;// 打印 \"Is it a spicy red pepper?\" 不同于java ，swift的case语句不必加break。 注意let在上述例子的等式中是如何使用的，它将匹配等式的值赋给常量x。let x where x.hasSuffix(&quot;papper&quot;)这句话的意思是先把vegetable的值赋给x，如果赋值成功，再判断调用hasSuffix方法判断是否以pepper字符串结尾。 运行switch中匹配到的子句之后，程序会退出switch语句，并不会继续向下运行，所以不需要在每个子句结尾写break。 你可以使用for-in来遍历字典，需要两个变量来表示每个键值对。字典是一个无序的集合，所以他们的键和值以任意顺序迭代结束。 下面的程序演示了找出最大值的操作： 12345678910111213let interestingNumbers = [ \"Prime\": [2, 3, 5, 7, 11, 13], \"Fibonacci\": [1, 1, 2, 3, 5, 8], \"Square\": [1, 4, 9, 16, 25]]var largest = 0for (kind, numbers) in interestingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125;&#125;print(largest) // 25 使用while来重复运行一段代码直到不满足条件。循环条件也可以在结尾，保证能至少循环一次。 1234567891011var n = 2while n &lt; 100 &#123; n = n * 2&#125;print(n) // 128var m = 2repeat &#123; m = m * 2&#125; while m &lt; 100print(m) // 128 你可以在循环中使用..&lt;来表示范围，也可以使用传统的写法，两者是等价的： 1234567891011var firstForLoop = 0for i in 0..&lt;4&#123; firstForLoop += i&#125;print(firstForLoop) // 6var secondForLoop = 0for var i = 0; i &lt; 4; ++i &#123; secondForLoop += i&#125;print(secondForLoop) // 6 函数和闭包使用func来声明一个函数，使用名字和参数来调用函数。使用-&gt;来指定函数返回值的类型。 1234func greet(name: String, day: String) -&gt; String &#123; return \"Hello \\(name), today is \\(day).\"&#125;greet(\"Bob\", day: \"Tuesday\") 使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。 12345678910111213141516171819func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) &#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min, max, sum)&#125;let statistics = calculateStatistics([5, 3, 100, 3, 9])print(statistics.min)print(statistics.max)print(statistics.sum)print(statistics.2) 函数可以带有可变个数的参数，这些参数的函数内表现为数组的形式： 123456789func sumOf(numbers: Int...) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125;sumOf()sumOf(42, 597, 12) 函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数 。 123456789func returnFifteen() -&gt; Int &#123; var y = 10 func add() &#123; y += 5 &#125; add() return y&#125;returnFifteen() 函数是第一等类型，这意味着函数可以作为另一个函数的返回值。 12345678func makeIncrementer() -&gt; (Int -&gt; Int) &#123; func addOne(number: Int) -&gt; Int &#123; return 1 + number &#125; return addOne&#125;var increment = makeIncrementer()increment(7) 函数也可以当做参数传入另一个函数。 12345678910111213func hasAnyMatches(list: [Int], condition: Int -&gt; Bool) -&gt; Bool &#123; for item in list &#123; if condition(item) &#123; return true &#125; &#125; return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10&#125;var numbers = [20, 19, 7, 12]hasAnyMatches(numbers, condition: lessThanTen) 函数实际上是一种特殊的闭包：它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 — 你已经在嵌套函数例子中所看到。你可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型声明与闭包函数体进行分离。 123456var numbers = [20, 19, 7, 12]numbers.map(&#123; (number: Int) -&gt; Int in let result = 3 * number return result&#125;) 有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。 12let mappedNumbers = numbers.map(&#123; number in 3 * number &#125;)print(mappedNumbers) // [60, 57, 21, 36] swift内置了一组变量($0、$1、$2 ……)，上述代码还能更简单 12mappedNumbers = numbers.map(&#123; $0 * 3 &#125;)print(mappedNumbers) 你可以通过参数位置而不是参数名字引用 参数 — 这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。 12let sortedNumbers = numbers.sort&#123; $0 &gt; $1 &#125;print(sortedNumbers) // [20, 19, 12, 7] 对象和类使用class和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。 123456class Shape &#123; var numberOfSides = 0 func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSides) sides.\" &#125;&#125; 要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。 123var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription() 这个版本的Shape类缺少了一些重要的东西：一个构造函数来初始化类实例。使用init来创建一个构造器。 12345678910class NamesShape &#123; var numberOfSides: Int = 0 var name: String init (name: String) &#123; self.name = name &#125; func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSides) sides.\" &#125;&#125; 注意self被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。 每个属性都需要赋值 — 无论是通过声明（就像numberOfSides）还是通过构造器（就像name） 如果你需要在删除对象之前进行一些清理工作，使用deinit创建一个析构函数。 子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。 子类如果要重写父类的方法的话，需要用override标记 — 如果没有添加override就重写父类的方法的话，编译器会报错。编译器同样会检测override标记的方法是否确实在父类中。 123456789101112131415161718class Square: NamesShape &#123; var sideLength: Double init(sideLength: Double, name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 4 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func simpleDescription() -&gt; String &#123; return \"A square with sides of length \\(sideLength).\" &#125;&#125;let test = Square(sideLength: 5.2, name: \"my test square\")test.area() // 27.04test.simpleDescription() // \"A square with sides of length 5.2\" 除了储存简单的属性之外，属性可以有 getter和settter。 1234567891011121314151617181920212223class EquilateralTriangle: NamesShape &#123; var sideLength: Double = 0.0 init(sideLength: Double, name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 4 &#125; var perimeter: Double &#123; get&#123; return 3.0 * sideLength &#125; set &#123; sideLength = newValue / 3.0 &#125; &#125; override func simpleDescription() -&gt; String &#123; return \"An equilateral triagle with sides of length \\(sideLength).\" &#125;&#125;let triangle = EquilateralTriangle(sideLength: 3.1, name: \"a triangle\")print(triangle.perimeter) // 9.3triangle.perimeter = 9.9print(triangle.sideLength) // 3.3 在perimeter的setter中，新值的名字是newValue。你可以在set之后显示的设置一人名字。 注意EquilateralTriangle类的构造器执行了三步： 设置子类声明的属性 调用父类的构造器 改变父类定义的属性值。其它的工作比如调用方法、getter和setter也可以在这个阶段完成。 如果你不需要计算属性，但是仍然需要在设置一相新值之前或者之后运行代码，使用willSet和didSet。 比如，下面的类确保三角形的边长总是和正方形的边长相同。 123456789101112131415161718192021class TriangleAndSquare &#123; var triangle: EquilateralTriangle &#123; willSet &#123; square.sideLength = newValue.sideLength &#125; &#125; var square: Square &#123; willSet&#123; triangle.sideLength = newValue.sideLength &#125; &#125; init(size: Double, name: String) &#123; square = Square(sideLength: size, name: name) triangle = EquilateralTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10, name: \"another test shape\")print(triangleAndSquare.square.sideLength) // 10print(triangleAndSquare.triangle.sideLength) // 10triangleAndSquare.square = Square(sideLength: 50, name: \"larger square\")print(triangleAndSquare.triangle.sideLength) // 50 处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加?。如果 ?之前的值是nil，?后面的东西都会被忽略，并且整个表达式返回nil。否则，?之后的东西都会被运行。在这两种情况下，整个表达 式的值也是一个可选值。 12let optionalSquare: Square? = Square(sideLength: 2.5, name: \"optional square\")let sideLength = optionalSquare?.sideLength 枚举和结构体使用enum来创建一个枚举。就像类的其他所有命名类型一样，枚举可以包含方法。 123456789101112131415161718192021enum Rank: Int &#123; case Ace = 1 case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King func simpleDescription() -&gt; String &#123; switch self &#123; case .Ace: return \"ace\" case .Jack: return \"jack\" case .Queen: return \"queen\" case .King: return \"king\" default: return String(self.rawValue) &#125; &#125;&#125;let ace = Rank.Acelet aceRawValue = ace.rawValue 在上面的例子中，枚举原始值的类型是Int，所以你只需要设置第一个原始值。剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为枚举的原始值。使用rawValue属性来访问一个枚举成员的原始值。 使用init?(rawValue:)初始化构造器在原始值和枚举值之间进行转换。 123if let convertedRank = Rank(rawValue: 3) &#123; let threeDescription = convertedRank.simpleDescription()&#125; 枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，以防原始值没有意义，你不需要设置。 1234567891011121314151617enum Suit &#123; case Spades, Hearts, Diamonds, Clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .Spades: return \"spades\" case .Hearts: return \"hearts\" case .Diamonds: return \"diamonds\" case .Clubs: return \"clubs\" &#125; &#125;&#125;let hearts = Suit.Heartslet heartsDescription = hearts.simpleDescription() 注意，有两种方式可以引用Hearts成员：给hearts常量赋值时，枚举成员Suit.Hearts需要用全名来引用，因为常量没有显式指定类型。在switch里，枚举成员使用缩写.Hearts来引用，因为self的值已经知道是一个suit。已知变量类型的情况下你可以使用缩写。 使用struct来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的一个区别就是结构体是传值，类是传引用。 123456789struct Card &#123; var rank: Rank var suit: Suit func simpleDescription() -&gt; String &#123; return \"The \\(rank.simpleDescription()) of \\(suit.simpleDescription())\" &#125;&#125;let threeOfSpades = Card(rank: .Three, suit: .Spades)let threeOfSpadesDescription = threeOfSpades.simpleDescription() 一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值和原始值是不同的：枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。 例如，考虑从服务器获取日出和日落的时间。服务器会返回正常结果或者错误信息。 123456789101112enum ServerResponse &#123; case Result(String, String) case Error(String)&#125;let success = ServerResponse.Result(\"6:00 am\", \"8:09 pm\")let failure = ServerResponse.Error(\"Out of cheese.\")switch success &#123;case let .Result(sunrise, sunset): let serverResponse = \"Sunrise is at \\(sunrise) and sunset is at \\(sunset).\"case let .Error(error): let serverResponse = \"Failure... \\(error)\"&#125; 注意如何从ServerResponse中提取日升和日落时间并用得到的值用来和switch的情况做比较。 协议和扩展使用protocol来声明一个协议。 1234protocol ExampleProtocol &#123; var simpleDescription: String &#123; get &#125; mutating func adjust()&#125; 类、枚举和结构体都可以实现协议。 12345678910111213141516171819class SimpleClass: ExampleProtocol &#123; var simpleDescription: String = \"A very simple class.\" var anotherProperty: Int = 69105 func adjust() &#123; simpleDescription += \" Now 100% adjusted.\" &#125;&#125;var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionstruct SimpleStructure: ExampleProtocol &#123; var simpleDescription: String = \"A simple structure\" mutating func adjust() &#123; simpleDescription += \"(adjusted)\" &#125;&#125;var b = SimpleStructure()b.adjust()let bDescription = b.simpleDescription 注意声明SimpleStructure时候mutating关键字用来标记一个会修改结构体的方法。SimpleClass的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质） 使用extension来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。 123456789extension Int: ExampleProtocol &#123; var simpleDescription: String &#123; return \"The number \\(self)\" &#125; mutating func adjust() &#123; self += 42 &#125;&#125;print(7.simpleDescription) // The number 7 你可以像使用其他命名类型一样使用协议名 — 例如，创建一个有不同类型但是都实现一个协议的对象集合。当你处理类型是协议的值时，协议外定义的方法不可用。 12let protocolValue: ExampleProtocol = aprint(protocolValue.simpleDescription) //A very simple class. Now 100% adjusted. 即使protocolValue变量运行时的类型是simpleClass，编译器会把它的类型当做ExampleProtocol。这表示你不能调用类在它实现的协议之外实现的方法或属性。 泛型在尖括号里写一个名字来创建一个泛型函数或者类型。 12345678func repeatItem&lt;Item&gt;(item: Item, numberOfTimes: Int) -&gt; [Item] &#123; var result = [Item]() for _ in 0..&lt;numberOfTimes &#123; result.append(item) &#125; return result&#125;repeatItem(\"knock\", numberOfTimes: 4) // [\"knock\", \"knock\", \"knock\", \"knock\"] 你也可以创建泛型函数 、方法、类、枚举和结构体。 1234567// Reimplement the Swift standard library's optional typeenum OptionalValue&lt;Wrapped&gt; &#123; case None case Some(Wrapped)&#125;var possibleInteger: OptionalValue&lt;Int&gt; = .NonepossibleInteger = .Some(100) 在类型名后面的使用where来指定对类型的需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类。 1234567891011func anyCommonElements&lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;(lhs: T, _ rhs: U) -&gt; Bool &#123; for lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125;anyCommonElements([1, 2, 3], [3]) &lt;T: Equatable&gt;和&lt;T where T: Equatable&gt;是等价的。","tags":[{"name":"ios","slug":"ios","permalink":"yzbzz.github.io/tags/ios/"}]},{"title":"Stream","date":"2016-05-19T06:52:26.000Z","path":"2016/05/19/java/java8-stream/","text":"概述本篇会介绍Steam类中的一组方法，每个方法都对应集合上的一种操作 迭代定义一个集合 1List&lt;String&gt; numbers = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;); 外部迭代 12345678910// 使用for循环for (String number : numbers) &#123; System.out.println(number);&#125;// 迭代器Iterator&lt;String&gt; iterator = numbers.iterator();while (iterator.hasNext())&#123; String number = iterator.next(); System.out.println(number);&#125; 内部迭代（Stream） 1numbers.stream().forEach(action -&gt; System.out.println(action)); 实现机制 Stream操作分为==惰性求值方法==和==及早求值方法== 看下面一个例子 12numbers.stream().filter(predicate -&gt; predicate.equals(\"2\")); //返回值Stream&lt;String&gt;numbers.stream().filter(predicate -&gt; predicate.equals(\"2\")).count(); //返回值int 对于第1种，这行代码并未做什么实际性的工作，filter只刻画出了Stream，但没有产生新的集合。像filter这样只描述Stream，最终不产生新集合的方法叫作==惰性求值方法==；对于第2种的count这样最终会从Stream产生值的方法叫作==及早求值方法== 1234567// 由于使用了惰性求值，没有输出数字Stream&lt;String&gt; stream = numbers.stream().filter(predicate -&gt; &#123; System.out.println(predicate); return predicate.equals(\"2\");&#125;);// 调用Count，输出了数字stream.count(); // 输出了1、2、3 判断一个操作是惰性求值还是及早求值很简单：只需看它的返回值。如果返回值是Stream，那么是惰性求值；如果返回值是另一个值或为空，那么就是及早求值。整个过程和==建造者模式==有共通之处。建造者模式使用一系列操作设置属性和配置，最后调用一个==build==方法，这时，对象才被真正的创建。 常用的流操作collect(toList())1List&lt;String&gt; collected = Stream.of(\"1\", \"2\", \"3\").collect(Collectors.toList()); mapmap操作符用于将一个流中的值转换成一个新的流 123456789// 先调用Stream的of方法生成一个Stream流，再调用map方法把Stream流中的(a,b,c)转成大写List&lt;String&gt; collected = Stream.of(\"a\", \"b\", \"c\") .map(string -&gt; string.toUpperCase()).collect(Collectors.toList());// 等价于List&lt;String&gt; collected = new ArrayList&lt;String&gt;();for (String string : Arrays.asList(\"a\", \"b\", \"c\")) &#123; collected.add(string.toUpperCase());&#125; filter遍历数据并检查其中的元素时，可尝试使用Stream中的filter操作符 123// 下面代码的意思是从Stream流中取大于3的元素List&lt;Integer&gt; collected = Stream.of(1, 2, 3, 4, 5, 6) .filter(predicate -&gt; (predicate &gt; 3)).collect(Collectors.toList()); flatmapflatmap方法可用Stream替换值，然后将多个Stream连接成一个Stream 123456789// 把2个list合并成一个List&lt;Integer&gt; together = Stream.of(Arrays.asList(1, 2), Arrays.asList(3, 4)) .flatMap(mapper -&gt; mapper.stream()).collect(Collectors.toList());System.out.println(together); // 输出[1,2,3,4]// 先计算2个list的个数，再把2个list的个数合并成一个listList&lt;Integer&gt; together = Stream.of(Arrays.asList(1, 2), Arrays.asList(3, 4, 5)) .flatMap(mapper -&gt; Stream.of(mapper.size())).collect(Collectors.toList());System.out.println(together); // 输出[2,3] max和minStream上常用的操作之一是求最大值和最小值。Stream API中的max和min操作足以解决这一问题。 定义一个Track类和集合： 1234567891011121314public class Track &#123; public String name; public int count; public Track(String name, int count) &#123; this.name = name; this.count = count; &#125; public int getLength() &#123; return name.length(); &#125;&#125; 1234List&lt;Track&gt; tracks = Arrays.asList( new Track(\"Bakai\", 524), new Track(\"Violets for Your Furs\", 378), new Track(\"Time\",451)); 求Track 123456// 求name最小的TrackTrack shortestTrack = tracks.stream().min(Comparator.comparing(track -&gt; track.getLength())).get();// 求name最大的TrackTrack shortestTrack = tracks.stream() .max(Comparator.comparing(track -&gt; track.getLength())).get(); 调用max和min，会返回一个Optional对象。Optional它代表一个可能存在也可能不存在的值。如果Stream为空，那么该值不存在，如果不为空，则该值存在。调用get方法可以取出Optional对象中的值 reducereduce操作可以实现从一组值中生成一个值 123// 使用reduce求和int count = Stream.of(1, 2, 3, 4, 5).reduce(0, (acc, element) -&gt; acc + element);System.out.println(count); // 返回15 1+2+3+4+5 Lambda表达式的返回值是最新的acc，是上一轮acc的值和当前元素相加的结果。reduce的类型是之前Lambda文章介绍过的BinaryOperator。点此查看Lambda 整合操作下面的例子演示了找出一年级的所有同学 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Classes &#123; public String name; public List&lt;Student&gt; students = new ArrayList&lt;Classes.Student&gt;(); public static class Student &#123; public String name; public Student(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"name: \" + name; &#125; &#125; public static void main(String[] args) &#123; Classes classesOne = new Classes(); classesOne.name = \"一年级\"; classesOne.students.addAll( Arrays.asList(new Student(\"张三\"), new Student(\"李四\"))); Classes classesTwo = new Classes(); classesTwo.name = \"二年级\"; classesTwo.students.addAll( Arrays.asList(new Student(\"王五\"), new Student(\"赵六\"))); List&lt;Classes&gt; classes = new ArrayList&lt;Classes&gt;(); classes.add(classesOne); classes.add(classesTwo); List&lt;Student&gt; students = classes.stream(). filter(predicate -&gt; predicate.name.equalsIgnoreCase(\"一年级\")). flatMap(mapper -&gt; mapper.students.stream()). collect(Collectors.toList()); for (Student student : students) &#123; System.out.println(student.toString()); &#125; &#125;&#125; 计算学生名字长度 12345678IntSummaryStatistics intSummaryStatistics =classesTwo.students.stream() .mapToInt(mapper -&gt; mapper.name.length()) .summaryStatistics();System.out.println(intSummaryStatistics.getAverage()); // 2.0System.out.println(intSummaryStatistics.getCount()); // 2System.out.println(intSummaryStatistics.getMax()); // 2System.out.println(intSummaryStatistics.getMin()); // 2System.out.println(intSummaryStatistics.getSum()); // 4","tags":[{"name":"java","slug":"java","permalink":"yzbzz.github.io/tags/java/"},{"name":"stream","slug":"stream","permalink":"yzbzz.github.io/tags/stream/"}]},{"title":"Lambda 表达式","date":"2016-05-19T06:18:52.000Z","path":"2016/05/19/java/java8-lambda/","text":"概述Java 8 的最大变化是引入了Lambda表达式 —— 一种紧凑的、传递行为的方式，接下来就了解一下什么是Lambda表达式。 为什么要叫这个名字呢？这多年前，在计算机出现之前，有位名叫Alonzo Church的逻辑学家，他想要证明什么样的数学函数是可以有效计算的(奇怪的是，当时已经存在了许多已知的函数，但是没有人知道怎么去计算它们的值)。他使用希腊字母的lambda(𝛌)来标记参数 。为什么使用𝛌?难道Church没有其它拉丁字母可用了吗？事实上经典的《数学原理》中使用”^”符号表示自由变量，这启发Church使用大写的lambda &quot;Λ&quot;来表示参数。但是最终，他选择换回到小写版本。于是从那时起，还有参数变量的表达式都被称为lambda表达式。 第一个Lambda表达式 Lambda表达式适用于只包含一个方法的接口的情况，表如：Runnable接口，只包含一个run方法。 正常情况: 123456new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Hello\"); &#125;&#125;).start(); 使用Lambda: 12new Thread(() -&gt; System.out.println(\"Hello\")).start();new Thread(() -&gt; &#123;System.out.println(\"Hello\");&#125;).start(); 你已经见到了 Java 中的 lambda 表达式的格式：参数、箭头 -&gt;，以及一个表达式 Lambda表达式的不同形式1234567891.Runnable noArguments = () -&gt; System.out.println(\"Hello World\");2.ActionListener oneArguments = event -&gt; System.out.println(\"Button Clicked\");3.Runnable multiStatement = () -&gt; &#123; System.out.println(\"Hello\"); System.out.println(\"World\"); &#125;;4.BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;5.BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;6.变种 System.out::println Lambda表达式不包含参数，使用空括号表示没有参数 Lambda表达式包含且只包含一个参数，可省略参数的括号，如上面示例中的第2种情况 Lambda表达式不仅可以是一个表达式，而且也可以是一段代码块，使用大括号({})将代码块括起来，如上面示例中的第3种情况。 注：只有一行代码的Lambda表达式也可使用大括号，但需要在表达式后面加上一个分号。 Lambda表达式也可以包含多个参数的方法，如示例中的第4种情况。这时就有必要思考怎么样去阅读该Lambda表达式。这行代码并不是将两个数字相加，而是创建一个函数 ，用来计算两个数字相加的结果。变量add的类型是BinaryOperator，它不是两个数字的和，而是将两个数字相加的那行代码。 所有Lambda表达式的参数类型都是由编译器推断得出的。但有时也可以显示声明参数类型，此时就需要使用小括号将参数括起来，多个参数也是如此。如上面示例中的第5种情况 详情请阅读下面的 方法引用 章节 你可以像对待方法参数一样向lambda表达式的参数添加注解或者final修饰符，如下： 123&gt; (final String name) -&gt; ...&gt; (@NonNull String name) -&gt; ...&gt; &gt; 注意：在lambda表达式中，只在某些分支中返回值(其它分支没有返回值)是不合法的。例如: 12&gt; (int x) -&gt; &#123; if (x &gt; 0) return 1; &#125;&gt; 引用值，而不是变量 Lambda表示式中引用的局部变量，必须是final或既成事实上的final变量 什么是既成事实上的final变量呢？看看下面这种情况： 12String test = \"hello\";new Thread(() -&gt; System.out.println(test)).start(); 对于变量test，虽然可以不用final修饰(编译不会报错)，但是只要你对test再赋值其它值，就会编译报错，这种情况就是既成事实的final变量 函数接口 函数接口是只有一个抽象方法的接口，用作lambda表达式的类型 你可能奇怪为什么函数接口必须只有一个抽象方法。难道接口中的方法不都是抽象的吗？事实上，接口经常会重新声明Object类中的方法，例如toString或者clone，而这些方法声明并不是抽象的。 使用Java编程，总会遇到很多函数接口，但 Java 开发工具包（JDK）提供的一组核心函数接口会频繁出现。如下： 接口 参数 返回类型 示例 Predicata T boolean 这张唱片已经发行了吗 Consumer T void 输出一个值 Function T R 获取Artist对象的名字 Supplier None T 工厂方法 UnaryOperator T T 逻辑非(!) BinaryOperator (T, T) T 求两个数的乘积(*) 你可以在任意函数式接口上标注@FunctionalInterface注解，这样做有两个好处。首先，编译器会检查标注该注解的实体，检查它是否是只包含一个抽象方法的接口。别外，在 javadoc 页面也会包含一条声明，说明这个接口是一个函数式接口。 该注解并不要求强制使用。从概念上来讲，所有只包含一个抽象方法的接口都是函数式接口，但是使用@FuncationalInterface注解会让你的代码看上去更清楚。 最后，当一个 lambda 表达式被转换为一个函数接口的实例时，请注意处理检查期异常。如果 lambda 表达式中可能会抛出一个检查期异常，那么该异常需要在目标接口的抽象方法中进行声明。例如，以下表达式会产生一个错误： 12Runnable sleeper = () -&gt; &#123; System.out.println(\"Zzz\"); Thread.sleep(1000); &#125;;// 错误：Thread.sleep可以抛出一个检查期的 InterruptedException. 由于 Runnable.run 不能抛出任何异常，所有这个赋值不是合法的，有两种方法可以修正该问题。一种是在 lambda 表达式中捕获异常，别一种是将 lambda 表达式赋给一个其抽象方法可以抛出异常的接口。例如，Callable 接口的 call 方法可以抛出任何异常，因此，你可以将该 lambda 表达式赋给 Callable (如果你添加一条 “return null” 语句)。 方法引用 一共有四种类型的方法引用 类型 示例 类静态方法引用 ContainingClass::staticMethodName 某个对象的方法引用 参考文献：《Java8函数式编程》","tags":[{"name":"java","slug":"java","permalink":"yzbzz.github.io/tags/java/"},{"name":"lambda","slug":"lambda","permalink":"yzbzz.github.io/tags/lambda/"}]},{"title":"Android动画描述","date":"2016-05-19T02:54:29.000Z","path":"2016/05/19/android/android-animation/","text":"动画描述 XML配置 Java 类 描述 动画类型 alph AlphaAnimation 渐变透明度动画效果 渐变动画 scale ScaleAnimation 渐变尺寸伸缩动画效果 伸缩动画 translate TranslateAnimation 画面转换位置移动动画效果 画面转换动画(位移) rotate RotateAnimation 画面转移旋转动画效果 画面旋转动画 插入器 属性 描述 accelerate_decelerate_interpolator 加速-减速 accelerate_interpolator 加速 decelerate_interpolator 减速 XML配置123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;alpha //渐变 android:duration=\"1000\" //动画时长，单位毫秒 android:fromAlpha=\"0.0\" //动画起始时的透明度 0.0表示完全透明 android:toAlpha=\"1.0\" /&gt; //动画结束时的透明度 1.0表示完全不透明 &lt;scale //伸缩 android:duration=\"1000\" //动画时长，单位毫秒 android:fillAfter=\"false\" //当设置为true,该动画转化在动画结束后被应用 android:fromXScale=\"0.0\" //动画起始时 X坐标上的伸缩尺寸 0表示收缩到没有 android:fromYScale=\"0.0\" //动画起始时 Y坐标上的伸缩尺寸 1表示正常无伸缩 android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\" //插入器 android:pivotX=\"50%\" //动画相对于物件的X坐标的开始位置,从0%~100%取值，50%为中点位置 android:pivotY=\"50%\" //动画相对于物件的Y坐标的开始位置 android:toXScale=\"1.4\" //动画起始时 X坐标上的伸缩尺寸 小于1表示收缩 android:toYScale=\"1.4\" /&gt; //动画起始时 Y坐标上的伸缩尺寸 大于1表示放大 &lt;translate //位置转移 android:duration=\"2000\" //动画时长，单位毫秒 android:fromXDelta=\"30\" //动画开始时 X坐标的位置 android:fromYDelta=\"30\" //动画开始时 Y坐标的位置 android:toXDelta=\"-80\" //动画结束时 X坐标的位置 android:toYDelta=\"300\" /&gt; //动画结束时 Y坐标的位置 &lt;rotate android:duration=\"3000\" //动画时长，单位毫秒 android:fromDegrees=\"0\" //起始角度 android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"//插入器 android:pivotX=\"50%\" //动画相对于物件的X坐标的开始位置,从0%~100%取值，50%为中点位置 android:pivotY=\"50%\" //动画相对于物件的Y坐标的开始位置 android:toDegrees=\"+350\" /&gt; //结束角度，可以大于360度&lt;/set&gt;","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"about","date":"2016-05-18T15:16:31.000Z","path":"2016/05/18/about/","text":"人会长大三次。 第一次是在发现自己不是世界中心的时候。 第二次是在发现即使再怎么努力，终究还是有些事令人无能为力的时候。 第三次是在明知道有些事可能会无能为力。但还是会尽力争取的时候。","tags":[{"name":"me","slug":"me","permalink":"yzbzz.github.io/tags/me/"}]},{"title":"android-shape","date":"2016-05-18T09:28:11.000Z","path":"2016/05/18/android/android-shape/","text":"​ 在Android程序开发中，我们经常会用到Shape去定义各种各样的形状。shape可以在selector，layout等里面使用，有6个子标签，如下： Shape 格式123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;!-- 圆角，同时设置五个属性，则Radius属性无效 --&gt; &lt;corners android:radius=\"9dp\" //设置四个解的半径 android:topLeftRadius=\"2dp\" //设置左上角的半径 android:topRightRadius=\"2dp\" //设置右上角的半径 android:bottomLeftRadius=\"2dp\" //设置左下角的半径 android:bottomRightRadius=\"2dp\"/&gt; //设置右下角的半径 &lt;!-- 渐变，当设置填充颜色后，无渐变效果，angle的值必须是45的倍数(包括0)，仅在type=\"linear\"有效，角度以逆时针方向 --&gt; &lt;gradient android:startColor=\"@android:color/white\" android:centerColor=\"@android:color/black\" android:endColor=\"@android:color/black\" android:useLevel=\"true\" android:angle=\"45\" android:type=\"radial\" android:centerX=\"0\" android:centerY=\"0\" android:gradientRadius=\"90\"/&gt; &lt;!-- 间隔，设置四个方向的间隔--&gt; &lt;padding android:left=\"2dp\" android:top=\"2dp\" android:right=\"2dp\" android:bottom=\"2dp\"/&gt;&lt;!-- 各方向的间隔 --&gt; &lt;!-- 大小，设置大小--&gt; &lt;size android:width=\"50dp\" android:height=\"50dp\"/&gt;&lt;!-- 宽度和高度 --&gt; &lt;!-- 填充，设置填充的颜色 --&gt; &lt;solid android:color=\"@android:color/white\"/&gt;&lt;!-- 填充的颜色 --&gt; &lt;!-- 描边 dashWidth和dashGap属性，只要其中一个设置为0dp，则边框为实线边框--&gt; &lt;stroke android:width=\"2dp\" //设置边框的宽度 android:color=\"@android:color/black\" //设置边框的颜色 android:dashWidth=\"1dp\" //设置虚线的宽度 android:dashGap=\"2dp\"/&gt; //设置虚线的间隔宽度&lt;/shape&gt;","tags":[{"name":"android","slug":"android","permalink":"yzbzz.github.io/tags/android/"}]},{"title":"Hello World","date":"2016-05-18T09:17:35.000Z","path":"2016/05/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]